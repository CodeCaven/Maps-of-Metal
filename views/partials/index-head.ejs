<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
    <meta http-equiv="x-ua-compatible" content="ie=edge" />
    <title>Wiki Metal Vis</title>

    <!--<link rel="shortcut icon" type="image/jpg" href="/images/favicon.jpg"/> -->
    <!--<script src="./javascripts/forceGraph.js"></script>-->
    <script src="./javascripts/global.js"></script>
    <!--<script src="https://d3js.org/d3.v4.min.js"></script>-->
    <script src="https://d3js.org/d3.v6.js"></script>
    <script src="https://unpkg.com/d3-force-boundary@0.0.1/dist/d3-force-boundary.min.js"></script> <!--d3 force boundary add on-->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Turf.js/5.1.5/turf.min.js"></script><!--turf for d3 winding order-->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC" crossorigin="anonymous">
    <link rel='stylesheet' href='/stylesheets/style.css' />
    <link rel="stylesheet" href="https://unpkg.com/tippy.js@6/themes/translucent.css"/>
    <link rel="stylesheet" href="https://unpkg.com/tippy.js@6/animations/scale.css"/>
    <script type="text/javascript">

        // get data from controller
        let thrash_bands = JSON.parse(<%-JSON.stringify(ejs_thrash_bands)%>);
        let thrash_lookup = JSON.parse(<%-JSON.stringify(ejs_thrash_lookup)%>);
        let black_bands = JSON.parse(<%-JSON.stringify(ejs_black_bands)%>);
        let black_lookup = JSON.parse(<%-JSON.stringify(ejs_black_lookup)%>);
        let world_places = JSON.parse(<%-JSON.stringify(ejs_places)%>);
        let world_states = JSON.parse(<%-JSON.stringify(ejs_states)%>);
        let us_counties = JSON.parse(<%-JSON.stringify(ejs_counties)%>);
        let metal_continents = JSON.parse(<%-JSON.stringify(ejs_continents)%>);
        let us_state_data = JSON.parse(<%-JSON.stringify(ejs_state_data)%>);

        // global units
        let vhu;
        let vwu;

        // global functions
        let update_bands;

        // global vars "United States of America" "United Kingdom"
        // NOTE: may need to use "mapunits" for homeland regions (france, us, etc)
        //       may also need breakdown of canadian states
        let current_projection;
        let simulation;
        let svg;
        let region = "California";
        let display_region = "US"; // World
        let pop_max = 2500000;
        let THEME = "light";
        let current_year = 1978;
        let prev_year;
        let display_continent = "North America"; // test for contnent grouping
        let us_region = "Midwest"; // state regions needs debugging
        let nodes = [];
        let links = [];
        let spacing = 30;
        

        // DOM loaded callback
		document.addEventListener('DOMContentLoaded', function() {

            // d3 and geojson
            // https://www.d3indepth.com/geographic/
            // https://github.com/martynafford/natural-earth-geojson/blob/master/10m/cultural/ne_10m_populated_places.json

            // natural earth country names
            // https://unstats.un.org/unsd/methodology/m49/

           // log data
           console.log(thrash_bands);
           console.log(thrash_lookup);
           console.log(black_bands);
           console.log(black_lookup);
           console.log(world_places);
           console.log(world_states);
           console.log(us_counties);
           console.log(metal_continents);
           console.log(us_state_data);

           // global units
           vhu = parseFloat(window.innerHeight/100);
           vwu = parseFloat(window.innerWidth/100);
           console.log("height and width window units");
           console.log(vhu);
           console.log(vwu);

           // set chart height (bootstrap determines width)
           document.getElementById("plot_div").style.height = "90vh";

           // event listeners
           document.getElementById('yearControl').addEventListener("click", handleYear);

           // set year and area display
           document.getElementById("yearDisplay").innerHTML = current_year;

           // set background by theme
           if(THEME == "dark"){
           document.body.style.backgroundColor = "black";
           }else{
            document.body.style.backgroundColor = "white";
           }

           
           draw_map();
           create_graph(current_projection);
           
         }, false);

         /* EVENT HANDLERS*/
         function handleYear(event){
            var direction = event.target.id;
            var year_display = document.getElementById("yearDisplay");

            if(direction=='left'){
                if(current_year == 1973){
                    return;
                }
                else{
                    prev_year = current_year;
                    current_year -= 1;
                    year_display.innerHTML = current_year;
                    //var graph = create_graph(current_projection);
                    //update_bands(graph);
                    update_graph(current_projection);
                    return;
                }
            }

            if(direction=='right'){
                if(current_year == 2024){
                    return;
                }
                else{
                    prev_year = current_year;
                    current_year += 1;
                    year_display.innerHTML = current_year;
                    //var graph = create_graph(current_projection);
                    //update_bands(graph);
                    update_graph(current_projection);
                    return;
                }
            }
         }

         // check if country in continent
         function in_continent(country){
            for(let i in metal_continents){
                if(metal_continents[i]["name"] == country){
                    if(metal_continents[i]["continent"] == display_continent){
                        return true;
                    }
                    else{
                        return false;
                    }
                }
            }
            return false;
         }

         // check if us state in region
         function in_us_region_fips(state){
            for(let i in us_state_data){
                if(us_state_data[i]["fips-code"] == state){
                    if(us_state_data[i]["region"] == us_region){
                        return true;
                    }
                    else{
                        return false;
                    }
                }
            }
            return false;
         }

         // check if us state in region
         function in_us_region_name(state){
            for(let i in us_state_data){
                if(us_state_data[i]["name"] == state){
                    if(us_state_data[i]["region"] == us_region){
                        return true;
                    }
                    else{
                        return false;
                    }
                }
            }
            return false;
         }

         function update_graph(projection){

            // get indexes
            var prev_band_indexes = thrash_lookup[prev_year];
            var curr_band_indexes = thrash_lookup[current_year];

            // bands to add/remove
            var add_indexes = curr_band_indexes.filter(i => !prev_band_indexes.includes(i));
            var remove_indexes = prev_band_indexes.filter(i => !curr_band_indexes.includes(i));

            // create new nodes and links
            for(let a of add_indexes){

                // get band
                var band = thrash_bands.filter(o => o.index == a)[0];

                // US
                if(display_region == "US" && band['loc']['state'] == region){

                    // create nodes (2 for eaach band)
                    var new_base_node = {"id": "base" + band['index'], "type":"thrash", "nodeType":"base",
                                            "lat":band['loc']['latitude'], "long":band['loc']['longitude'], "logo": band['logo'],
                                            "fx": projection([band['loc']['longitude'], band['loc']['latitude']])[0],
                                            "fy": projection([band['loc']['longitude'], band['loc']['latitude']])[1],
                                            "x": projection([band['loc']['longitude'], band['loc']['latitude']])[0],
                                            "y": projection([band['loc']['longitude'], band['loc']['latitude']])[1]};

                    var new_band_node = {"id": "band" + band['index'], "type":"thrash", "nodeType":"band",
                    "lat":band['loc']['latitude'], "long":band['loc']['longitude'], "logo": band['logo'],
                    "x": projection([band['loc']['longitude'], band['loc']['latitude']])[0],
                    "y": projection([band['loc']['longitude'], band['loc']['latitude']])[1]};

                    var new_link = {"source":"base" + band['index'], 
                                    "target":"band" + band['index'],
                                    "value": spacing};
                    spacing += 10;
                    nodes.push(new_base_node);
                    nodes.push(new_band_node);
                    links.push(new_link);
                }

                // World
                if(display_region == "World" && band['loc']['country'] == region){

                    // create nodes (2 for eaach band)
                    var new_base_node = {"id": "base" + band['index'], "type":"thrash", "nodeType":"base",
                                            "lat":band['loc']['latitude'], "long":band['loc']['longitude'], "logo": band['logo'],
                                            "fx": projection([band['loc']['longitude'], band['loc']['latitude']])[0],
                                            "fy": projection([band['loc']['longitude'], band['loc']['latitude']])[1],
                                            "x": projection([band['loc']['longitude'], band['loc']['latitude']])[0],
                                            "y": projection([band['loc']['longitude'], band['loc']['latitude']])[1]};

                    var new_band_node = {"id": "band" + band['index'], "type":"thrash", "nodeType":"band",
                    "lat":band['loc']['latitude'], "long":band['loc']['longitude'], "logo": band['logo'],
                    "x": projection([band['loc']['longitude'], band['loc']['latitude']])[0],
                    "y": projection([band['loc']['longitude'], band['loc']['latitude']])[1]};

                    var new_link = {"source":"base" + band['index'], 
                                    "target":"band" + band['index'],
                                    "value": spacing};

                    spacing += 10;
                    nodes.push(new_base_node);
                    nodes.push(new_band_node);
                    links.push(new_link);
                }
            }

            // remove nodes and links
            for(let r of remove_indexes){

                // get band
                var band = thrash_bands.filter(o => o.index == r)[0];

                // remove 2 nodes
                nodes = nodes.filter(obj => obj.id != "band" + band['index'] && obj.id != "base" + band['index']);

                // remove link
                links = links.filter(obj => obj.source.id != "base" + band['index'])
                spacing -= 10;
            }

            //console.log(nodes);
            //console.log(links);
            update_bands();

         }

         // create a graph of nodes and edges by current year
         function create_graph(projection){

            // current year thrash indexes
            var thrash_indexes = thrash_lookup[current_year];
            for(let band of thrash_bands){

                // US
                if(display_region == "US" && band['loc']['state'] == region){
                    if(thrash_indexes.includes(band['index'])){
                        
                        // create nodes (2 for eaach band) and link
                        var new_base_node = {"id": "base" + band['index'], "type":"thrash", "nodeType":"base",
                                        "lat":band['loc']['latitude'], "long":band['loc']['longitude'], "logo": band['logo'],
                                        "fx": projection([band['loc']['longitude'], band['loc']['latitude']])[0],
                                        "fy": projection([band['loc']['longitude'], band['loc']['latitude']])[1],
                                        "x": projection([band['loc']['longitude'], band['loc']['latitude']])[0],
                                        "y": projection([band['loc']['longitude'], band['loc']['latitude']])[1]};

                        var new_band_node = {"id": "band" + band['index'], "type":"thrash", "nodeType":"band",
                        "lat":band['loc']['latitude'], "long":band['loc']['longitude'], "logo": band['logo'],
                        "x": projection([band['loc']['longitude'], band['loc']['latitude']])[0],
                        "y": projection([band['loc']['longitude'], band['loc']['latitude']])[1]};

                        var new_link = {"source":"base" + band['index'], 
                                    "target":"band" + band['index'],
                                    "value": spacing};

                        spacing += 10
                        nodes.push(new_base_node);
                        nodes.push(new_band_node);
                        links.push(new_link);
                    }
                }

                // World
                if(display_region == "World" && band['loc']['country'] == region){
                    if(thrash_indexes.includes(band['index'])){

                        // create nodes (2 for eaach band) and link
                        var new_base_node = {"id": "base" + band['index'], "type":"thrash", "nodeType":"base",
                                        "lat":band['loc']['latitude'], "long":band['loc']['longitude'], "logo": band['logo'],
                                        "fx": projection([band['loc']['longitude'], band['loc']['latitude']])[0],
                                        "fy": projection([band['loc']['longitude'], band['loc']['latitude']])[1],
                                        "x": projection([band['loc']['longitude'], band['loc']['latitude']])[0],
                                        "y": projection([band['loc']['longitude'], band['loc']['latitude']])[1]};

                        var new_band_node = {"id": "band" + band['index'], "type":"thrash", "nodeType":"band",
                        "lat":band['loc']['latitude'], "long":band['loc']['longitude'], "logo": band['logo'],
                        "x": projection([band['loc']['longitude'], band['loc']['latitude']])[0],
                        "y": projection([band['loc']['longitude'], band['loc']['latitude']])[1]};

                        var new_link = {"source":"base" + band['index'], 
                                    "target":"band" + band['index'],
                                    "value": spacing};

                        spacing += 10;
                        nodes.push(new_base_node);
                        nodes.push(new_band_node);
                        links.push(new_link);
                    }
                }
            }
            update_bands();
         }

         function draw_map(){
            // get width and height of plot area
            var plot_area = document.getElementById("plot_div");
            var plot_height = plot_area.offsetHeight;
            var plot_width = plot_area.offsetWidth;

            // set the dimensions and margins of the plot 
            var margin = {top: 0, 
                        right: 0, 
                        bottom: 0, 
                        left: 0};

            // chart width and height (leaving names from old code)
            var width = plot_width - margin.left - margin.right;
            var height = plot_height - margin.top - margin.bottom;

            // remove any elements in plot area
            while (plot_area.firstChild) {
                plot_area.removeChild(plot_area.firstChild);
            }

            // zoom
            function zoomed(event) {
                const {transform} = event;
                svg.attr("transform", transform);
                //svg.attr("stroke-width", 1 / transform.k);
            }

            let zoom = d3.zoom()
                .scaleExtent([0.5, 20])
                .on('zoom', zoomed);

            // append the svg object to the plot area
            svg = d3.select("#plot_div")
            .append("svg")
                .attr("id" , "svgArea")
                .attr("width", plot_width)
                .attr("height", plot_height)
                .attr("viewBox", [0, 0, plot_width, plot_height]) // add zoom here to avoid pan jitter
                .attr("style", "width: 100%; height: auto; height: intrinsic;")
                .style("background-color", "black")
                //.call(zoom)
            .append("g")
                .attr("transform",
                    "translate(" + margin.left + "," + margin.top + ")");

            // background
            svg.
            append("rect")
            .attr("id", "backLine")
            .attr("width", width)
            .attr("height",height)
            .attr("fill", function(){
                if(THEME == "dark"){return "black"}
                return "white";
            })
            .attr("x",margin.left)
            .attr("y",margin.top);

            let mapColour = "darkolivegreen";
            svg = create_light_filter(svg);
            svg = create_gradient_filter(svg, mapColour);

            /*** Filter Map  ***/ 

            // us counties and places
            if(display_region == "US"){
                var display_states = us_counties.features.filter(prop => prop.properties.STATE == us_state_data[region]["fips_code"]);
                var places_points = world_places.features.filter(prop => prop.properties.ADM1NAME == region && prop.properties.POP_MAX > pop_max);

                // by region (needs debugging)
                //var display_states = us_counties.features.filter(prop => in_us_region_fips(prop.properties.STATE));
                //var places_points = world_places.features.filter(prop => in_us_region_name(prop.properties.ADM1NAME) && prop.properties.POP_MAX > pop_max);
            }   
            else{ // world states and places
                var display_states = world_states.features.filter(prop => prop.properties.admin == region);
                var places_points = world_places.features.filter(prop => prop.properties.ADM0NAME == region && prop.properties.POP_MAX > pop_max);

                // by continent
                //var display_states = world_states.features.filter(prop => in_continent(prop.properties.admin));
                //var places_points = world_places.features.filter(prop => in_continent(prop.properties.ADM0NAME) && prop.properties.POP_MAX > pop_max);
            }

            // turf unwind features for plot
            var fixed_states = display_states.map(function(f) {
                    return turf.rewind(f,{reverse:true});
            });

            // Map and projection ...Mercator
            let proj = d3.geoMercator(); 
            proj.fitSize([width,height],{"type": "FeatureCollection","features":fixed_states});
            current_projection = proj;
            const path = d3.geoPath().projection(current_projection);

            // scales
            var radScale = d3.scaleSqrt()
            .domain([pop_max, 10*pop_max])
            .range([1*vhu, 3*vhu]).clamp(true);

            var textScale = d3.scaleLinear()
            .domain([pop_max, 10*pop_max])
            .range([1, 3]).clamp(true);

            
            // counties or states
            svg
            .append("g")
            .selectAll("path")
            .data(fixed_states)
            .join("path")
            .attr("d", path)
            //.attr("fill", "khaki")
            .attr("fill","url(#middleCircleFill)")
            .attr("stroke", function(){
                if(THEME == "dark"){return mapColour}
                return mapColour;
            })
            .attr("stroke-width", 2)
            .attr("class", "statearea");

            // add links (here so behind other elements)
            var link = svg.append("g")
            .attr("class", "links")
            .selectAll("edges");

            // add base nodes (circle) here so behind
            var node = svg.append("g")
            .attr("class", "nodes")
            .call(d3.drag()
                .on("start", dragstarted)
                .on("drag", dragged)
                .on("end", dragended)).selectAll("bands");


            /*** place names **/
            var place_radius = 7;
            // add first for bounding box
            svg
            .selectAll("text")
            .data(places_points)
            .enter()
            .append("text")
            .attr('dy', d => -2*place_radius) //-2*radScale(d.properties.POP_MAX
            .style('font-size', d => textScale(d.properties.POP_MAX)+"rem")
            .attr("letter-spacing", "2px")
            .attr("text-anchor", "start")
            .text(d => d.properties.NAME)
            .call(getBB);

            // remove the text elements (watch for other text elements)
            d3.selectAll("text").remove();

            // add background rects
            const xMargin = 8
            const yMargin = 4
            svg
            .selectAll("textareas")
            .data(places_points)
            .enter()
            .append("rect")
            .attr("class", "maprect")
            .attr("x", d => current_projection(d.geometry.coordinates)[0])
            .attr("y", d => current_projection(d.geometry.coordinates)[1] - 2*place_radius)
            .attr("width", d => d.bbox.width + 2 * xMargin)
            .attr("height", d => d.bbox.height + 2 * yMargin)
            .style("fill", function(){
                if(THEME == "dark"){return "white"}
                return "white";
            })
            .style("fill-opacity", 0.9)
            .attr('transform', function(d) {
                return `translate(-${xMargin}, -${d.bbox.height * 0.8 + yMargin})`
                });
            
           // add the text back
           svg
            .selectAll("text")
            .data(places_points)
            .enter()
            .append("text")
            .attr("x", d => current_projection(d.geometry.coordinates)[0])
            .attr("y", d => current_projection(d.geometry.coordinates)[1])
            .attr('dy', d => -2*place_radius)
            .attr("stroke", function(){
                if(THEME == "dark"){return "black"}
                return "black";
            })
            .attr("fill", function(){
                if(THEME == "dark"){return "black"}
                return "black";
            })
            .style('font-size', d => textScale(d.properties.POP_MAX)+"rem")
            .attr("letter-spacing", "2px")
            .attr("text-anchor", "start")
            .text(d => d.properties.NAME);
            
        /* FORCE SIMULATION */
        //var graph = create_graph(current_projection);
        //console.log(graph);

        // Create a simulation with several forces.
        // https://observablehq.com/@d3/force-directed-graph/2?collection=@d3/d3-force
        simulation = d3.forceSimulation(nodes).alpha(0.5)
            .force("link", d3.forceLink(links).id(d => d.id).distance(200).strength(0.3))
            .force("collide", d3.forceCollide().radius(20))
            .force("boundary", forceBoundary(0, 0, plot_width, plot_height - 100).strength(0.005))
            .on("tick", ticked);
          
            
        // add nodes
        /*
        var node = svg.append("g")
        .attr("class", "nodes")
        .attr("fill", "red")
        .attr("stroke", "blue")
        .attr("stroke-width", 2)
        .style("stroke-opacity", 0.5)
        .call(d3.drag()
            .on("start", dragstarted)
            .on("drag", dragged)
            .on("end", dragended)).selectAll("bands");
        */

        // add band nodes (image)
        var image_node = svg.append("g")
        .attr("class", "nodes")
        .call(d3.drag()
            .on("start", dragstarted)
            .on("drag", dragged)
            .on("end", dragended)).selectAll("images");

        
        // places
        /*
        svg
            .selectAll("places")
            .data(places_points)
            .enter()
            .append("circle")
            .attr("cx", d => current_projection(d.geometry.coordinates)[0])
            .attr("cy", d => current_projection(d.geometry.coordinates)[1])
            .attr("r", function(d){
                return radScale(d.properties.POP_MAX);
            })
            .attr("filter", "url(#specular)")
            .attr("stroke", "white")
            .attr("fill", "purple")
            .attr("stroke-width", 3)
            .attr("fill-opacity", 1)
            .attr("stroke-opacity", 0.7);
            */

        
            
        // ticked function
        function ticked() {
            
            link
            .attr("x1", d => d.source.x)
            .attr("y1", d => d.source.y)
            .attr("x2", d => d.target.x)
            .attr("y2", d => d.target.y);
    
            image_node
            .attr("x", d => d.x)
            .attr("y",d => d.y);

            node
            .attr("cx", d => d.x)
            .attr("cy",d => d.y);
            
        }

        update_bands = function(){

            // Make a shallow copy to protect against mutation, while
            // recycling old nodes to preserve position and velocity.
            //const old = new Map(node.data().map(d => [d.id, d]));
            //nodes = nodes.map(d => ({...old.get(d.id), ... d}));
            //links = links.map(d => ({...d}));

            simulation.nodes(nodes);
            simulation.force("link").links(links);
            simulation.alpha(0.5).restart().tick();
            
            
            node = node
                .data(nodes, d => d.id)
                .join(enter => enter.append("circle")
                .attr("class", "nodes")
                .attr("fill", "blue")
                .attr("stroke", "white")
                .attr("stroke-width", 2)
                .style("stroke-opacity", 0.7)
                .attr("filter", "url(#specular)")
                .attr("r", function(d){
                    if(d.nodeType == "base"){return place_radius;}
                    return 0;
                }));
            node.exit().remove();
            
            image_node = image_node
                .data(nodes, d => d.id)
                .join(enter => enter.append("image")
                .attr("class", "nodes")
                .attr("xlink:href", d => "logos/" + d.logo)
                .attr("height", function(d){
                    if(d.nodeType=="base"){return 0;}
                    return 30;
                })
                .attr("alt", d => d.display_name)
                .call(d3.drag()
                    .on("start", dragstarted)
                    .on("drag", dragged)
                    .on("end", dragended)));
                
            image_node.exit().remove();

            //link = link.exit.remove();
            link = link
                .data(links, d => [d.source, d.target])
                .join("line")
                .attr("class", "links")
                .attr("stroke-width", 1)
                .attr("stroke-opacity", 0.5)
                .attr("fill", "blue")
                .attr("stroke", "blue");
            link.exit().remove();

            
            ticked(); // render now!

             
        }

        // get bb of text
        function getBB(selection) {
            selection.each(function(d){d.bbox = this.getBBox();})
        }
            
    }

    

        
  // Reheat the simulation when drag starts, and fix the subject position.
  function dragstarted(event) {
    if (!event.active) simulation.alphaTarget(0.3).restart();
    event.subject.fx = event.subject.x;
    event.subject.fy = event.subject.y;
  }

  // Update the subject (dragged node) position during drag.
  function dragged(event) {
    event.subject.fx = event.x;
    event.subject.fy = event.y;
  }

  // Restore the target alpha so the simulation cools after dragging ends.
  // Unfix the subject position now that it’s no longer being dragged.
  function dragended(event) {
    if (!event.active) simulation.alphaTarget(0);
    event.subject.fx = null;
    event.subject.fy = null;
  }

    </script>
</head>