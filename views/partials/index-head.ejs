<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
    <meta http-equiv="x-ua-compatible" content="ie=edge" />
    <title>Wiki Metal Vis</title>

    <!--<link rel="shortcut icon" type="image/jpg" href="/images/favicon.jpg"/> -->
    <!--<script src="./javascripts/forceGraph.js"></script>-->
    <script src="./javascripts/global.js"></script>
    <!--<script src="https://d3js.org/d3.v4.min.js"></script>-->
    <script src="https://d3js.org/d3.v6.js"></script>
    <script src="https://unpkg.com/d3-force-cluster@latest"></script><!--clsuter force-->
    <script src="https://unpkg.com/d3-force-boundary@0.0.1/dist/d3-force-boundary.min.js"></script> <!--d3 force boundary add on-->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Turf.js/5.1.5/turf.min.js"></script><!--turf for d3 winding order-->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC" crossorigin="anonymous">
    <link href="https://fonts.cdnfonts.com/css/iomanoid" rel="stylesheet"> <!--font-->
    <link href="https://fonts.cdnfonts.com/css/metal-lord" rel="stylesheet"><!--font-->
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Honk"><!--Google font-->
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Permanent+Marker"><!--Google font-->
    <link rel='stylesheet' href='/stylesheets/style.css' />
    <link rel="stylesheet" href="https://unpkg.com/tippy.js@6/themes/translucent.css"/>
    <link rel="stylesheet" href="https://unpkg.com/tippy.js@6/animations/scale.css"/>
    <script type="text/javascript">

        // get data from controller
        let thrash_bands = JSON.parse(<%-JSON.stringify(ejs_thrash_bands)%>);
        let thrash_lookup = JSON.parse(<%-JSON.stringify(ejs_thrash_lookup)%>);
        let black_bands = JSON.parse(<%-JSON.stringify(ejs_black_bands)%>);
        let black_lookup = JSON.parse(<%-JSON.stringify(ejs_black_lookup)%>);
        let world_places = JSON.parse(<%-JSON.stringify(ejs_places)%>);
        let world_states = JSON.parse(<%-JSON.stringify(ejs_states)%>);
        let world_boundaries = JSON.parse(<%-JSON.stringify(ejs_map_countries)%>);
        let us_counties = JSON.parse(<%-JSON.stringify(ejs_counties)%>);
        let us_states = JSON.parse(<%-JSON.stringify(ejs_us_states)%>);
        let metal_continents = JSON.parse(<%-JSON.stringify(ejs_continents)%>);
        let us_state_data = JSON.parse(<%-JSON.stringify(ejs_state_data)%>);

        // global units
        let vhu;
        let vwu;

        // global functions
        let update_chart;

        // global vars and objects
        let animate_timeout;
        let current_projection;
        let simulation;
        let us_region = "Northeast"; 
        let world_region = "South America"; 
        let region = "Italy"; // "United States of America" "United Kingdom"
        let display_region = "World"; // World
        let grouped_region = true;
        let display_continent = "North America"; // need to manuually create list for continents
        let pop_max = 1500000;
        let THEME = "dark";
        let current_year = 1979;
        let prev_year;
        let nodes = [];
        let links = [];
        let display_bands = {"thrash": true, "black": false};
        let changes = false;
        let image_display_range = [];
        let image_height = 30;
        var timeout = 6000;
        let image_range_object = {getRange: function(){ // watch for lots of nodes
                    let image_width_range = [];
                    if(nodes.length/2 < 30){
                        image_width_range.push(vwu*5) // min..6
                        image_width_range.push(vwu*9) // max..10
                        return image_width_range;
                    }
                    else if(nodes.length/2 < 60){
                        image_width_range.push(vwu*5) // min
                        image_width_range.push(vwu*9) // max
                        return image_width_range;
                    }
                    else if(nodes.length/2 < 90){
                        image_width_range.push(vwu*4) // min
                        image_width_range.push(vwu*8) // max
                        return image_width_range;
                    }
                    else if(nodes.length/2 < 120){
                        image_width_range.push(vwu*4) // min
                        image_width_range.push(vwu*8) // max
                        return image_width_range;
                    }
                    else if(nodes.length/2 < 150){
                        image_width_range.push(vwu*3) // min
                        image_width_range.push(vwu*8) // max
                        return image_width_range;
                    }
                    else if(nodes.length/2 < 180){
                        image_width_range.push(vwu*3) // min
                        image_width_range.push(vwu*7) // max
                        return image_width_range;
                    }
                    else if(nodes.length/2 < 210){
                        image_width_range.push(vwu*3) // min
                        image_width_range.push(vwu*6) // max
                        return image_width_range;
                    }
                    else{
                        image_width_range.push(vwu*3) // min
                        image_width_range.push(vwu*5) // max
                        return image_width_range;
                    }
        }}
        
        let projections = {getProjection: function(region, width, height, fixed_states){
                    let padding = 0; /// germany 50, italy 50
                    if(region == "Norway"){
                        return d3.geoMercator().scale(900)
                        .center([10.75224540, 65.91386880]) // long, lat
                        .translate([width/2, height/2]);
                    }
                    if(region == "Scandinavia"){
                        return d3.geoMercator().scale(700)
                        .center([12.75224540, 64.91386880])
                        .translate([width/2, height/2]);
                    }
                    else if(region == "World"){
                        return d3.geoMercator().scale(200)
                        .center([39.00, 34.00])
                        .translate([width/2, height/2]);
                            //.fitSize([width,height],{"type": "FeatureCollection","features":fixed_states});
                    }
                    else{ // fitextent sets translate and scale, fitsize is shortcut for fitextent with top. left 0. 0 (cant use with padding)
                        return d3.geoMercator()
                            .fitExtent([[0, padding], [width,height-padding]],{"type": "FeatureCollection","features":fixed_states});
                            //.fitSize([width,height],{"type": "FeatureCollection","features":fixed_states});
                    }// will need to tinker with South
                
                }
        }

        // DOM loaded callback
		document.addEventListener('DOMContentLoaded', function() {

            // d3 and geojson
            // https://www.d3indepth.com/geographic/
            // https://github.com/martynafford/natural-earth-geojson/blob/master/10m/cultural/ne_10m_populated_places.json

            // natural earth country names
            // https://unstats.un.org/unsd/methodology/m49/

           // log data
           console.log(thrash_bands);
           console.log(thrash_lookup);
           console.log(black_bands);
           console.log(black_lookup);
           console.log(world_places);
           console.log(world_states);
           console.log(world_boundaries);
           console.log(us_counties);
           console.log(us_states);
           console.log(metal_continents);
           console.log(us_state_data);

           // umique cities
           let unique_cities = world_places.features.map(prop => prop.properties.NAME_EN);
           unique_cities.sort();
           console.log(unique_cities);

           // set New Mexico to South (change in data!)
           us_state_data["New Mexico"]["region"] = "South";

           // global units
           vhu = parseFloat(window.innerHeight/100);
           vwu = parseFloat(window.innerWidth/100);
           console.log("height and width window units");
           console.log(vhu);
           console.log(vwu);

           // set chart height (bootstrap determines width)
           document.getElementById("plot_div").style.height = "98vh";

           // event listeners
           document.getElementById('yearControl').addEventListener("click", handleYear);

           // set year and area display
           document.getElementById("yearDisplay").innerHTML = current_year;
           if(!(grouped_region)){
                document.getElementById("regionDisplay").innerHTML = region;
           }
           else{// will need to update for world continents
                if(display_region == "US"){
                    document.getElementById("regionDisplay").innerHTML = "US " + us_region;
                }
                else{
                    document.getElementById("regionDisplay").innerHTML = world_region;
                }
           }

           // init draggable controls
           dragElement(document.getElementById("controls"));

           // set background by theme
           if(THEME == "dark"){
             document.body.style.backgroundColor = "black";
             document.getElementById("yearDisplay").style.color = "white";
           }else{
             document.body.style.backgroundColor = "white";
             document.getElementById("yearDisplay").style.color = "black";
           }

           draw_map();
           update_chart();
           
           animate_timeout = setInterval(myFunction, timeout);
           //animate();

         }, false);

         // varying time interval animation
         var myFunction = function(){
            var skip_years = [1980,1981,1982,1983,1988,1989,1994,1995,1996,2000,2001,2003,
                            2009, 2010, 2011, 2012, 2014, 2015, 2016, 2017, 2018, 2019, 2020, 2021, 2022, 2023];
            clearInterval(animate_timeout);
            if(timeout == 0){
                timeout = 3000;
                return;} // stop from handle year
            if(current_year == 2024){
                clearInterval(animate_timeout);
                return;}
            // update the map
            var year_display = document.getElementById("yearDisplay");
            prev_year = current_year;
            current_year += 1;
            year_display.innerHTML = current_year;
            update_graph_all_genres();
            //if(timeout <= 4500){timeout += 500;}
            
            //if(skip_years.includes(current_year)){timeout = 3000;}
            //else if(current_year <= 1987){timeout = 2000;}
            //else{timeout = 7000;}
            timeout = 8000;
            //if(current_year >= 2014){timeout = 2000;}
            //else if(current_year >= 2020){timeout = 10000;}
            //else{timeout = 10000;}
            //if(current_year == 1985 || current_year == 1987){timeout = 3000;}
            animate_timeout = setInterval(myFunction, timeout);
        }
       
        

         // animate function
         function animate(){
           
            animate_timeout = setInterval(function(){
                var year_display = document.getElementById("yearDisplay");
                prev_year = current_year;
                current_year += 1;
                year_display.innerHTML = current_year;
                update_graph_all_genres();
                if(current_year == 2024){clearInterval(animate_timeout);}
            }, 8000)
         }

         /* EVENT HANDLERS*/
         function handleYear(event){

            // stop animation
            timeout = 0;
            clearInterval(animate_timeout);

            // get direction and handle
            var direction = event.target.id;
            var year_display = document.getElementById("yearDisplay");

            if(direction=='left'){
                if(current_year == 1973){
                    return;
                }
                else{
                    prev_year = current_year;
                    current_year -= 1;
                    year_display.innerHTML = current_year;
                    update_graph_all_genres();
                    return;
                }
            }

            if(direction=='right'){
                if(current_year == 2024){
                    return;
                }
                else{
                    prev_year = current_year;
                    current_year += 1;
                    year_display.innerHTML = current_year;
                    update_graph_all_genres();
                    return;
                }
            }
         }

         //** create and update all
         function create_graph_all_genres(){
            if(display_bands["thrash"]){
                create_graph(current_projection, thrash_lookup, thrash_bands, "thrash");
            }

            if(display_bands["black"]){
                create_graph(current_projection, black_lookup, black_bands, "black");
            }
    
         }

         function update_graph_all_genres(){
            if(display_bands["thrash"]){
                update_graph(current_projection, thrash_lookup, thrash_bands, "thrash");
            }

            if(display_bands["black"]){
                update_graph(current_projection, black_lookup, black_bands, "black");
            }
            update_chart();
            changes = false;
         }

         //** check functions

         // check if country in continent
         function in_continent(country){
            for(let i in metal_continents){
                if(metal_continents[i]["name"] == country){
                    if(metal_continents[i]["continent"] == display_continent){
                        return true;
                    }
                    else{
                        return false;
                    }
                }
            }
            return false;
         }

         // check if us state in region
         function in_us_region_fips(state){
            for(let i in us_state_data){
                if(us_state_data[i]["fips_code"] == state){
                    if(us_state_data[i]["region"] == us_region){
                        return true;
                    }
                    else{
                        return false;
                    }
                }
            }
            return false;
         }

         // check if country in world region
         function in_world_region(country){
            return world_regions[world_region].includes(country);
         }

         // check if us state in region
         function in_us_region_name(state){
            for(let i in us_state_data){
                if(us_state_data[i]["name"] == state){
                    if(us_state_data[i]["region"] == us_region){
                        return true;
                    }
                    else{
                        return false;
                    }
                }
            }
            return false;
         }

         //** update graph
         function update_graph(projection, lookup, bands, genre){

            // get indexes
            var prev_band_indexes = lookup[prev_year];
            var curr_band_indexes = lookup[current_year];

            // bands to add/remove
            var add_indexes = curr_band_indexes.filter(i => !prev_band_indexes.includes(i));
            var remove_indexes = prev_band_indexes.filter(i => !curr_band_indexes.includes(i));

            // create new nodes and links
            for(let a of add_indexes){

                // get band
                var band = bands.filter(o => o.index == a)[0];

                // US
                if((!(grouped_region) && display_region == "US" && band['loc']['state'] == region) || 
                        (grouped_region && display_region == "US" && in_us_region_name (band['loc']['state']))){

                    changes = true;

                    // create nodes (2 for eaach band)
                    var new_base_node = {"id": "base" + genre + band['index'], "type":genre, "nodeType":"base",
                                            "lat":band['loc']['latitude'], "long":band['loc']['longitude'], "logo": band['logo'],
                                            "fx": projection([band['loc']['longitude'], band['loc']['latitude']])[0],
                                            "fy": projection([band['loc']['longitude'], band['loc']['latitude']])[1],
                                            "x": projection([band['loc']['longitude'], band['loc']['latitude']])[0],
                                            "y": projection([band['loc']['longitude'], band['loc']['latitude']])[1],
                                            "image_size": band["image_size"], "name": band["name"]};

                    var new_band_node = {"id": "band" + genre + band['index'], "type":genre, "nodeType":"band",
                    "lat":band['loc']['latitude'], "long":band['loc']['longitude'], "logo": band['logo'],
                    "x": projection([band['loc']['longitude'], band['loc']['latitude']])[0],
                    "y": projection([band['loc']['longitude'], band['loc']['latitude']])[1],
                    "image_size": band["image_size"], "origin": band['origin'], "name": band["name"]};

                    var new_link = {"source":"base" + genre + band['index'], 
                                    "target":"band" + genre + band['index'],
                                    "type":genre, "image_size": band["image_size"], "name": band["name"]};
                    nodes.push(new_base_node);
                    nodes.push(new_band_node);
                    links.push(new_link);
                }

                // World
                if((!(grouped_region) && display_region == "World" && band['loc']['country'] == region) || 
                        (grouped_region && display_region == "World" && in_world_region (band['loc']['country']))){

                    changes = true;

                    // create nodes (2 for eaach band)
                    var new_base_node = {"id": "base" + genre + band['index'], "type":genre, "nodeType":"base",
                                            "lat":band['loc']['latitude'], "long":band['loc']['longitude'], "logo": band['logo'],
                                            "fx": projection([band['loc']['longitude'], band['loc']['latitude']])[0],
                                            "fy": projection([band['loc']['longitude'], band['loc']['latitude']])[1],
                                            "x": projection([band['loc']['longitude'], band['loc']['latitude']])[0],
                                            "y": projection([band['loc']['longitude'], band['loc']['latitude']])[1],
                                            "image_size": band["image_size"], "name": band["name"]};

                    var new_band_node = {"id": "band" + genre + band['index'], "type":genre, "nodeType":"band",
                    "lat":band['loc']['latitude'], "long":band['loc']['longitude'], "logo": band['logo'],
                    "x": projection([band['loc']['longitude'], band['loc']['latitude']])[0],
                    "y": projection([band['loc']['longitude'], band['loc']['latitude']])[1],
                    "image_size": band["image_size"], "origin": band['origin'], "name": band["name"]};

                    var new_link = {"source":"base" + genre + band['index'], 
                                    "target":"band" + genre + band['index'],
                                    "type":genre, "image_size": band["image_size"], "name": band["name"]};

                    nodes.push(new_base_node);
                    nodes.push(new_band_node);
                    links.push(new_link);
                }
            }

            // remove nodes and links
            for(let r of remove_indexes){

                // get band
                var band = bands.filter(o => o.index == r)[0];

                // remove 2 nodes
                nodes = nodes.filter(obj => obj.id != "band" + genre + band['index'] && obj.id != "base" + genre + band['index']);
            
                // remove link
                links = links.filter(obj => obj.source.id != "base" + genre + band['index']);

                // checks for updates or not
                if((!(grouped_region) && display_region == "US" && band['loc']['state'] == region) || 
                        (grouped_region && display_region == "US" && in_us_region_name (band['loc']['state']))){
                    changes = true;
                }

                // World
                if((!(grouped_region) && display_region == "World" && band['loc']['country'] == region) || 
                        (grouped_region && display_region == "World" && in_world_region (band['loc']['country']))){
                    changes = true;
                }
            }
         }

         //** create a graph of nodes and edges by current year (initial)
         function create_graph(projection, lookup, bands, genre){

            // current year thrash indexes
            var thrash_indexes = lookup[current_year];
            for(let band of bands){

                // US
                if((!(grouped_region) && display_region == "US" && band['loc']['state'] == region) || 
                        (grouped_region && display_region == "US" && in_us_region_name (band['loc']['state']))){
                    if(thrash_indexes.includes(band['index'])){
                        
                        // create nodes (2 for eaach band) and link
                        var new_base_node = {"id": "base" + genre + band['index'], "type":genre, "nodeType":"base",
                                        "lat":band['loc']['latitude'], "long":band['loc']['longitude'], "logo": band['logo'],
                                        "fx": projection([band['loc']['longitude'], band['loc']['latitude']])[0],
                                        "fy": projection([band['loc']['longitude'], band['loc']['latitude']])[1],
                                        "x": projection([band['loc']['longitude'], band['loc']['latitude']])[0],
                                        "y": projection([band['loc']['longitude'], band['loc']['latitude']])[1],
                                        "image_size": band["image_size"], "name": band["name"]};

                        var new_band_node = {"id": "band" + genre + band['index'], "type":genre, "nodeType":"band",
                        "lat":band['loc']['latitude'], "long":band['loc']['longitude'], "logo": band['logo'],
                        "x": projection([band['loc']['longitude'], band['loc']['latitude']])[0],
                        "y": projection([band['loc']['longitude'], band['loc']['latitude']])[1],
                        "image_size": band["image_size"], "origin": band['origin'], "name": band["name"]};

                        var new_link = {"source":"base" + genre + band['index'], 
                                    "target":"band" + genre + band['index'],
                                    "type":genre, "image_size": band["image_size"], "name": band["name"]};

                        nodes.push(new_base_node);
                        nodes.push(new_band_node);
                        links.push(new_link);
                    }
                }

                // World
                if((!(grouped_region) && display_region == "World" && band['loc']['country'] == region) || 
                        (grouped_region && display_region == "World" && in_world_region (band['loc']['country']))){
                    if(thrash_indexes.includes(band['index'])){

                        // create nodes (2 for eaach band) and link
                        var new_base_node = {"id": "base" + genre + band['index'], "type":genre, "nodeType":"base",
                                        "lat":band['loc']['latitude'], "long":band['loc']['longitude'], "logo": band['logo'],
                                        "fx": projection([band['loc']['longitude'], band['loc']['latitude']])[0],
                                        "fy": projection([band['loc']['longitude'], band['loc']['latitude']])[1],
                                        "x": projection([band['loc']['longitude'], band['loc']['latitude']])[0],
                                        "y": projection([band['loc']['longitude'], band['loc']['latitude']])[1],
                                        "image_size": band["image_size"], "name": band["name"]};

                        var new_band_node = {"id": "band" + genre + band['index'], "type":genre, "nodeType":"band",
                        "lat":band['loc']['latitude'], "long":band['loc']['longitude'], "logo": band['logo'],
                        "x": projection([band['loc']['longitude'], band['loc']['latitude']])[0],
                        "y": projection([band['loc']['longitude'], band['loc']['latitude']])[1],
                        "image_size": band["image_size"], "origin": band['origin'], "name": band["name"]};

                        var new_link = {"source":"base" + genre + band['index'], 
                                    "target":"band" + genre + band['index'],
                                    "type":genre, "image_size": band["image_size"], "name": band["name"]};

                        nodes.push(new_base_node);
                        nodes.push(new_band_node);
                        links.push(new_link);
                    }
                }
            }
         }

         //** create a graph of nodes and edges by current year (initial)
         function create_world_graph(projection, lookup, bands, genre){

            // current year thrash indexes
            for(let band of bands){
                // create nodes (2 for eaach band) and link
                var new_base_node = {"id": "base" + genre + band['index'], "type":genre, "nodeType":"base",
                                "lat":band['loc']['latitude'], "long":band['loc']['longitude'], "logo": band['logo'],
                                "fx": projection([band['loc']['longitude'], band['loc']['latitude']])[0],
                                "fy": projection([band['loc']['longitude'], band['loc']['latitude']])[1],
                                "x": projection([band['loc']['longitude'], band['loc']['latitude']])[0],
                                "y": projection([band['loc']['longitude'], band['loc']['latitude']])[1],
                                "image_size": band["image_size"]};

                var new_band_node = {"id": "band" + genre + band['index'], "type":genre, "nodeType":"band",
                "lat":band['loc']['latitude'], "long":band['loc']['longitude'], "logo": band['logo'],
                "x": projection([band['loc']['longitude'], band['loc']['latitude']])[0],
                "y": projection([band['loc']['longitude'], band['loc']['latitude']])[1],
                "image_size": band["image_size"], "origin": band['origin']};

                var new_link = {"source":"base" + genre + band['index'], 
                            "target":"band" + genre + band['index'],
                            "type":genre, "image_size": band["image_size"]};

                nodes.push(new_base_node);
                nodes.push(new_band_node);
                links.push(new_link);
                
            }
         }

         function draw_map(){
            // get width and height of plot area
            var plot_area = document.getElementById("plot_div");
            var plot_height = plot_area.offsetHeight;
            var plot_width = plot_area.offsetWidth;

            // set the dimensions and margins of the plot 
            // NOTE: dont use for map margind, use padding var in projections instead
            var margin = {top: 0, 
                        right:0, 
                        bottom: 0, 
                        left: 0};

            // chart width and height (leaving names from old code)
            var width = plot_width - margin.left - margin.right;
            var height = plot_height - margin.top - margin.bottom;

            // remove any elements in plot area
            while (plot_area.firstChild) {
                plot_area.removeChild(plot_area.firstChild);
            }

            // zoom
            function zoomed(event) {
                const {transform} = event;
                svg.attr("transform", transform);
                //svg.attr("stroke-width", 1 / transform.k);
            }

            let zoom = d3.zoom()
                .scaleExtent([0.5, 20])
                .on('zoom', zoomed);

            // append the svg object to the plot area
            var svg = d3.select("#plot_div")
            .append("svg")
                .attr("id" , "svgArea")
                .attr("width", width)
                .attr("height", height)
                .attr("viewBox", [0, 0, width, height]) // add zoom here to avoid pan jitter
                .attr("style", "width: 100%; height: auto; height: intrinsic;")
                .style("background-color", function(){
                    if(THEME == "dark"){return "black";}
                    return "white";
                })
                .call(zoom)
            .append("g")
                .attr("transform",
                    "translate(" + margin.left + "," + margin.top + ")");

            let mapColour = "darkslategrey";
            svg = create_light_filter(svg, "lightskyblue");
            svg = create_light_filter(svg, "whitesmoke");
            svg = create_light_filter(svg, "darkrgray");
            svg = create_gradient_filter(svg, mapColour);

            // scales
            let radScale = d3.scaleSqrt()
            .domain([pop_max, 10*pop_max])
            .range([1*vhu, 3*vhu]).clamp(true);

            let textScale = d3.scaleLinear()
            .domain([100000, 5000000])
            .range([0.8, 1]).clamp(true);

            let imageScale = d3.scaleLinear()// using image range at the moment
            .domain([1, 200])// number of nodes
            .range([40, 15]).clamp(true); 

            /*** Filter Map  ***/ 
            // us counties and places
            if(display_region == "US"){
                if(!(grouped_region)){
                    var display_states = us_counties.features.filter(prop => prop.properties.STATE == us_state_data[region]["fips_code"]);
                    try{ // look up cities
                        var places_points = world_places.features.filter(prop => prop.properties.ADM1NAME == region);
                        places_points = places_points.filter(prop => views[region]["cities"].includes(prop.properties.NAME));
                    }
                    catch{// use pop if not found
                        var places_points = world_places.features.filter(prop => prop.properties.ADM1NAME == region && prop.properties.POP_MAX > pop_max);
                    }
                    var display_boundary = us_states.features.filter(prop => prop.properties.NAME == region);
                }

                // by region Northeast etc
                if(grouped_region){
                    var display_states = us_counties.features.filter(prop => in_us_region_fips(prop.properties.STATE));
                    try{
                        var places_points = world_places.features.filter(prop => in_us_region_name(prop.properties.ADM1NAME));
                        places_points = places_points.filter(prop => views[us_region]["cities"].includes(prop.properties.NAME_EN));
                     
                    }  
                    catch{
                        var places_points = world_places.features.filter(prop => in_us_region_name(prop.properties.ADM1NAME) && prop.properties.POP_MAX > pop_max);
                    }
                    
                    var display_boundary = us_states.features.filter(prop => in_us_region_name(prop.properties.NAME));
                }
            }   
            else{ // world states and places
                if(!(grouped_region)){
                    var display_states = world_states.features.filter(prop => prop.properties.admin == region);
                    try{ // look up cities
                        var places_points = world_places.features.filter(prop => prop.properties.ADM0NAME == region);
                        places_points = places_points.filter(prop => views[region]["cities"].includes(prop.properties.NAME_EN));
                    }
                    catch{ // use pop max if not found
                        var places_points = world_places.features.filter(prop => prop.properties.ADM0NAME == region && prop.properties.POP_MAX > pop_max);
                    }
                    
                    var display_boundary = world_boundaries.features.filter(prop => prop.properties.ADMIN == region);
                }

                // by world region (scandanavia, europe)
                if(grouped_region){
                    var display_states = world_states.features.filter(prop => in_world_region(prop.properties.admin));
                    try{
                        var places_points = world_places.features.filter(prop => in_world_region(prop.properties.ADM0NAME));
                        places_points = places_points.filter(prop => views[world_region]["cities"].includes(prop.properties.NAME_EN));
                     
                    }  
                    catch(e){
                        var places_points = world_places.features.filter(prop => in_world_region(prop.properties.ADM0NAME) && prop.properties.POP_MAX > pop_max);
                    }

                    var display_boundary = world_boundaries.features.filter(prop => in_world_region(prop.properties.ADMIN));
                }
            }
            
            // world
            //var display_states = world_states.features.filter(prop => prop.properties.admin != "Greenland");
            //var display_boundary = world_boundaries.features.filter(prop => prop.properties.ADMIN != "Greenland");
                    
            // turf unwind features for plot
            var fixed_states = display_states.map(function(f) {
                    return turf.rewind(f,{reverse:true});
            });

            // turf unwind features for plot (boundary)
            var fixed_boundary_states = display_boundary.map(function(f) {
                    return turf.rewind(f,{reverse:true});
            });

            // get and set current projection
            if(display_region == "World"){
                if(grouped_region){
                    current_projection = projections.getProjection(world_region ,width, height, fixed_states);
                }
                else{
                    current_projection = projections.getProjection(region ,width, height, fixed_states, margin);
                }
            }
            else{ // US
                if(grouped_region){
                    current_projection = projections.getProjection(us_region ,width, height, fixed_states);
                }
                else{
                    current_projection = projections.getProjection(region ,width, height, fixed_states, margin);
                }
            }
            
            // path and graph
            const path = d3.geoPath().projection(current_projection);
            create_graph_all_genres(); //create initial graph (needed for image nodes)

            // world graphs
            //create_world_graph(current_projection, thrash_lookup, thrash_bands, "thrash");
            //create_world_graph(current_projection, black_lookup, black_bands, "black");

            
            // counties or states
            svg
            .append("g")
            .selectAll("path")
            .data(fixed_states)
            .join("path")
            .attr("d", path)
            .attr("fill", mapColour)
            //.attr("fill","url(#middleCircleFill)")
            .attr("stroke", function(){
                if(THEME == "dark"){return "url(#middleCircleFill)"}
                return "url(#middleCircleFill)";
            })
            .attr("stroke-width", 1)
            .attr("stroke-opacity", 0.5)
            .attr("class", "statearea");

            // boundaries
            svg
            .append("g")
            .selectAll("boundary")
            .data(fixed_boundary_states)
            .join("path")
            .attr("d", path)
            .attr("fill", "none")
            //.attr("fill","url(#middleCircleFill)")
            .attr("stroke", function(){
                if(grouped_region){return "black";}
                return "url(#middleCircleFill)";
            })
            .attr("stroke-width", 1)
            .attr("stroke-opacity", 0.5);
            
            // add links (here so behind other elements)
            var link = svg.append("g")
            .attr("class", "links")
            .selectAll("edges");

            // add base nodes (circle specular) here so behind 
            var base_node = svg.append("g")
            .attr("class", "nodes")
            .selectAll("bands");

            /*** place names **/
            var place_radius = 20;
            var deltaX = 2.5*vwu;

            // add first for bounding box
            svg
            .selectAll("text")
            .data(places_points)
            .enter()
            .append("text")
            .attr("dx", function(d){
                if(anchors[d.properties.NAME_EN] == "start"){
                    return deltaX;
                };
                if(anchors[d.properties.NAME_EN] == "middle"){
                    return 0;
                };
                return -1*deltaX; // end
            })
            .attr("dy", function(d){
                if(anchors[d.properties.NAME_EN] == "start"){
                    return 0;
                };
                if(anchors[d.properties.NAME_EN] == "middle"){
                    return 1.5*place_radius;
                };
                return 0; // end
            })
            .style('font-size', d => textScale(d.properties.POP_MAX)+"rem")
            .attr("letter-spacing", "2px")
            //.attr("text-anchor", "end")
            .text(d => d.properties.NAME_EN)
            .call(getBB);

            // remove the text elements (watch for other text elements)
            d3.selectAll("text").remove();

            // add background rects
            const xMargin = 3;
            const yMargin = 2;
            svg
            .selectAll("textareas")
            .data(places_points)
            .enter()
            .append("rect")
            .attr("class", "maprect")
            .attr("x", function(d){
                if(anchors[d.properties.NAME_EN] == "start"){
                    return current_projection(d.geometry.coordinates)[0] + deltaX;
                };
                if(anchors[d.properties.NAME_EN] == "middle"){
                    return current_projection(d.geometry.coordinates)[0] - d.bbox.width/2;
                };
                return current_projection(d.geometry.coordinates)[0]  - deltaX - (d.bbox.width);
            })
            .attr("y", function(d){
                if(anchors[d.properties.NAME_EN] == "start"){
                    return current_projection(d.geometry.coordinates)[1];
                };
                if(anchors[d.properties.NAME_EN] == "middle"){
                    return current_projection(d.geometry.coordinates)[1] + (1.5*place_radius);
                };
                return current_projection(d.geometry.coordinates)[1]
            })
            .attr("width", d => d.bbox.width + 2 * xMargin)
            .attr("height", d => d.bbox.height + 2 * yMargin)
            .style("fill", function(){
                if(THEME == "dark"){return "white"}
                return "white";
            })
            .style("fill-opacity", 0.8)
            .attr('transform', function(d) {
                return `translate(-${xMargin}, -${d.bbox.height * 0.8 + yMargin})`
                });
            
           // add the text back
           svg
            .selectAll("text")
            .data(places_points)
            .enter()
            .append("text")
            .attr("x", d => current_projection(d.geometry.coordinates)[0])
            .attr("y", d => current_projection(d.geometry.coordinates)[1])
            .attr("dx", function(d){
                if(anchors[d.properties.NAME_EN] == "start"){
                    return deltaX;
                };
                if(anchors[d.properties.NAME_EN] == "middle"){
                    return 0;
                };
                return -1*deltaX; // end
            })
            .attr("dy", function(d){
                if(anchors[d.properties.NAME_EN] == "start"){
                    return 0;
                };
                if(anchors[d.properties.NAME_EN] == "middle"){
                    return 1.5*place_radius ;
                };
                return 0; // end
            })
            .attr("stroke", function(){
                if(THEME == "dark"){return "black"}
                return "black";
            })
            .attr("fill", function(){
                if(THEME == "dark"){return "black"}
                return "black";
            })
            .style('font-size', d => textScale(d.properties.POP_MAX)+"rem")
            .attr("letter-spacing", "2px")
            .attr("text-anchor", d => anchors[d.properties.NAME_EN])
            .text(d => d.properties.NAME_EN);
         
        
         
        /* FORCE SIMULATION */

        // Create a simulation with several forces.
        // https://github.com/ericsoco/d3-force-cluster
        // https://observablehq.com/@d3/force-directed-graph/2?collection=@d3/d3-force
        // collision warming
        // https://stamen.com/forcing-functions-inside-d3-v4-forces-and-layout-transitions-f3e89ee02d12/

        // add band nodes (image) NOTE: need to give image nodes data before update function (for positions i think)
        image_display_range = image_range_object.getRange();

        var node = svg.append("g").selectAll("images")
        .data(nodes, d => d.id)
        .enter().append('image')
        .attr("xlink:href", d => "logos_transparent/" + d.logo)
        .attr("height", function(d){

            if(d.nodeType=="base"){
                d['height'] = 0;
                return 0;}

            if(d.name == "Kerry King"){
                d['height'] = 87;
                return 87;
            }
                    
                    // image too small
                    var check_width = (image_height/d.image_size[1]) * d.image_size[0];
                    if(check_width < image_display_range[0]){
                        var set_height = (image_display_range[0]/d.image_size[0]) * d.image_size[1];
                        d['height'] = set_height;
                        return set_height;
                    }

                    // image too big
                    if(check_width > image_display_range[1]){
                        var set_height = (image_display_range[1]/d.image_size[0]) * d.image_size[1];
                        d['height'] = set_height;
                        return set_height;
                    }
                    d['height'] = image_height;
                    return image_height;
        })  
        .attr("width", function(d){ // only setting for collision detection
            if(d.nodeType=="base"){
                d['width'] = 0;
                return 0;}

            if(d.name == "Kerry King"){
                d['width'] = 207;
                return 207;
            }

                    
                    // image too small
                    var check_width = (image_height/d.image_size[1]) * d.image_size[0];
                    if(check_width < image_display_range[0]){
                        check_width = image_display_range[0];
                    }

                    // image too big
                    if(check_width > image_display_range[1]){
                        check_width = image_display_range[1];
                    }
                    d['width'] = check_width;
                    return check_width;
        })
        .attr("class", "nodes")
        .call(d3.drag()
            .on("start", dragstarted)
            .on("drag", dragged)
            .on("end", dragended));

        
        //** Simulation settings  // alphadecay 0.0028  velocitydecay 0.4
        simulation = d3.forceSimulation(nodes).alpha(0.1).velocityDecay(0.6)//.alphaDecay(0.1)//.velocityDecay(0.8)//.alpha(0.5).alphaDecay(0.1).velocityDecay(0.8)
            .force("link", d3.forceLink(links).id(d => d.id).distance(function(d){
                return 7*vwu;
                //if(d.index%2 == 0){return 100;}
                //if(d.index%3 == 0){return 80;}
                //if(d.index%4 == 0){return 60;}
                //return 120;
            }).strength(0.7))
            .force("collide", d3.forceCollide().radius(37).strength(0.5))
            //.force('collision', rectCollide().size(function(d){
                //console.log(d);
                //return [d.width,d.height]}))
            .force("forceY", d3.forceY().strength(0.1))   // can't index check to alternate on nodes
            //.force("forceX", d3.forceX().strength(0.05))
            //.force('cluster', d3.forceCluster().centers(get_clusters(width, height)).strength(0.5))
            .force("boundary", forceBoundary(0, 0, width, height-100).strength(0.1)) // 0.005
            .on("tick", ticked);
        
            
        // ticked function
        function ticked() {
            // source is base
            link
            .attr("x1", d => d.source.x)
            .attr("y1", d => d.source.y)
            .attr("x2", function(d){ // update target point to account for width/height

                // image too small
                var set_width = (image_height/d.image_size[1]) * d.image_size[0];
                if(set_width < image_display_range[0]){
                    var set_height = (image_display_range[0]/d.image_size[0]) * d.image_size[1];
                    var set_width = image_display_range[0];
                }
                // image too big
                else if(set_width > image_display_range[1]){
                    var set_height = (image_display_range[1]/d.image_size[0]) * d.image_size[1];
                    var set_width = image_display_range[1];
                }
                else{
                    var set_height = image_height;
                }

                if(d.name == "Kerry King"){
                    set_width = 207;
                    set_height = 87;
                }

                return d.target.x + set_width/2;
                
            })
            .attr("y2", function(d){
               // image too small
               var set_width = (image_height/d.image_size[1]) * d.image_size[0];
                if(set_width < image_display_range[0]){
                    var set_height = (image_display_range[0]/d.image_size[0]) * d.image_size[1];
                    var set_width = image_display_range[0];
                }
                // image too big
                else if(set_width > image_display_range[1]){
                    var set_height = (image_display_range[1]/d.image_size[0]) * d.image_size[1];
                    var set_width = image_display_range[1];
                }
                else{
                    var set_height = image_height;
                }

                if(d.name == "Kerry King"){
                    set_width = 207;
                    set_height = 87;
                }

                return d.target.y + set_height;;
            });
    
            node
            .attr("x", d => d.x)
            .attr("y", d => d.y);

            base_node
            .attr("cx", d => d.x)
            .attr("cy",d => d.y);
            
        }

        // global update chart (upate, enter, exit nodes and links)
        update_chart = function(){
            //console.log(nodes);
            //console.log(links);

            // set image range (watch this, may need to adjust)
            image_display_range = image_range_object.getRange();
            //console.log(image_display_range);

            // Dont use join as messes with exit
            // Instead define seperate enter() amd exit() and use merge as below
            // Always mutate the nodes/links arrays (ie manually add/remove and never overwrite)
            // update (existing), exit (remove old), enter (append new)


            //* base node

            // update existing nodes
            if(changes){
                base_node.data(nodes, d => d.id)
                .style("opacity", 0).transition().duration(4000).style("opacity", 1);
            }

            // give back data
            base_node = base_node.data(nodes, d => d.id);

            // exit nodes
            base_node.exit().transition().duration(2000).style("opacity", 0).remove();

            // enter new nodes
            base_node = base_node
                .enter().append("circle")
                .attr("class", "nodes")
                .attr("fill", function(d){
                    if(d.type == "black"){
                        return "black";
                    }

                    if(d.type == "thrash"){
                        return "lightblue";
                    }
                })
                .style("fill-opacity", 0)
                .attr("stroke", "white")
                .attr("stroke-width", 2)
                .style("stroke-opacity", 0)
                .attr("filter", function(d){
                    if(d.type == "black"){
                        return "url(#specularwhitesmoke)";
                    }

                    if(d.type == "thrash"){
                        return "url(#specularwhitesmoke)"; //"url(#specularlightskyblue)";
                    }
                
                })
                .attr("r", function(d){
                    if(d.nodeType == "base"){return place_radius;}
                    return 0;
                }).merge(base_node);
            
            
            //** image nodes

            // update existing nodes
            if(changes){

                // transition
                node.data(nodes, d => d.id)
                .style("opacity", 0).transition().duration(4000).style("opacity", 1);

                // resize
                
                node.data(nodes, d => d.id).attr("height", function(d){

                    if(d.nodeType=="base"){return 0;}

                    if(d.name == "Kerry King"){
                        return 87;
                    }
                    
                    // image too small
                    var check_width = (image_height/d.image_size[1]) * d.image_size[0];
                    if(check_width < image_display_range[0]){
                        var set_height = (image_display_range[0]/d.image_size[0]) * d.image_size[1];
                        return set_height;
                    }

                    // image too big
                    if(check_width > image_display_range[1]){
                        var set_height = (image_display_range[1]/d.image_size[0]) * d.image_size[1];
                        return set_height;
                    }
                    
                    return image_height;
                })
                .attr("width", function(d){ // only setting for collision detection
                    
                    if(d.nodeType=="base"){return 0;}

                    if(d.name == "Kerry King"){
                        return 207;
                    }
                
                    // image too small
                    var check_width = (image_height/d.image_size[1]) * d.image_size[0];
                    if(check_width < image_display_range[0]){
                        check_width = image_display_range[0];
                    }

                    // image too big
                    if(check_width > image_display_range[1]){
                        check_width = image_display_range[1];
                    }
                    return check_width;
                });
                
            }
            
            // then give data
            node = node.data(nodes, d => d.id);
            
            // exit nodes
            node.exit().transition().duration(2000).style("opacity", 0).remove();
            
            // enter new nodes
            node = node
                .enter().append("image")
                .attr("class", "nodes")
                .attr("xlink:href", d => "logos_transparent/" + d.logo)
                .attr("height", function(d){
                    
                    if(d.nodeType=="base"){
                        d['height'] = 0;
                        return 0;}

                    if(d.name == "Kerry King"){
                        d['height'] = 87;
                        return 87;
                    }
                    
                    // image too small
                    var check_width = (image_height/d.image_size[1]) * d.image_size[0];
                    if(check_width < image_display_range[0]){
                        var set_height = (image_display_range[0]/d.image_size[0]) * d.image_size[1];
                        d['height'] = set_height;
                        return set_height;
                    }

                    // image too big
                    if(check_width > image_display_range[1]){
                        var set_height = (image_display_range[1]/d.image_size[0]) * d.image_size[1];
                        d['height'] = set_height;
                        return set_height;
                    }
                    d['height'] = image_height;
                    return image_height;
                    

                })
                .attr("width", function(d){ // only setting for collision detection

                    if(d.nodeType=="base"){
                        d['width'] = 0;
                        return 0;}

                    if(d.name == "Kerry King"){
                        d['width'] = 207;
                        return 207;
                    }
                            
                    // image too small
                    var check_width = (image_height/d.image_size[1]) * d.image_size[0];
                    if(check_width < image_display_range[0]){
                        check_width = image_display_range[0];
                    }

                    // image too big
                    if(check_width > image_display_range[1]){
                        check_width = image_display_range[1];
                    }
                    d['width'] = check_width;
                    return check_width;
                })
                .call(d3.drag()
                .on("start", dragstarted)
                .on("drag", dragged)
                .on("end", dragended)).merge(node);

            //**  links

            // update existing
            if(changes){
                link.data(links, function(d) { return d.source.id + "-" + d.target.id; })
                .style("opacity", 0).transition().duration(4000).style("opacity", 1);
            }
            
            // then give back data
            link = link.data(links, function(d) { return d.source.id + "-" + d.target.id; });

            // exit links
            link.exit().transition().duration(2000).style("opacity", 0).remove();
            
            // enter new links
            link = link
                .enter()
                .append("line")
                .attr("class", "links")
                .attr("stroke", function(d){
                    if(d.type == "black"){
                        return "whitesmoke";
                    }

                    if(d.type== "thrash"){
                        return "whitesmoke"; //"lightskyblue";
                    }
                })
                .attr("stroke-width", 2)
                .attr("stroke-opacity", 0.1)
                .merge(link);
                
        
            simulation.nodes(nodes);
            simulation.force("link").links(links);
            simulation.alphaTarget(0.01).restart().tick();
            ticked(); // render now!
            
        }

        // get bb of text
        function getBB(selection) {
            selection.each(function(d){d.bbox = this.getBBox();})
        }
            
    }

    
    function get_clusters(w, h){
        // Determine the cluster points
        var clusters = [];

        clusters.push({
            cluster: 1,
            radius: 100,
            x: 50,
            y: 50
        });

        clusters.push({
            cluster: 2,
            radius: 100,
            x: w - 50,
            y: 50
        });

        clusters.push({
            cluster: 3,
            radius: 100,
            x: 50,
            y: h - 50
        });

        clusters.push({
            cluster: 4,
            radius: 100,
            x: w - 50,
            y: h - 50
        });

       return clusters;
    }
        
  // Reheat the simulation when drag starts, and fix the subject position.
  function dragstarted(event) {
    if (!event.active) simulation.alphaTarget(0.3).restart();
    event.subject.fx = event.subject.x;
    event.subject.fy = event.subject.y;
  }

  // Update the subject (dragged node) position during drag.
  function dragged(event) {
    event.subject.fx = event.x;
    event.subject.fy = event.y;
  }

  // Restore the target alpha so the simulation cools after dragging ends.
  // Unfix the subject position now that its no longer being dragged.
  function dragended(event) {
    if (!event.active) simulation.alphaTarget(0);
    event.subject.fx = null;
    event.subject.fy = null;
  }

  function rectCollide() {
    var nodes,sizes,masses;
    var strength = 5;
    var iterations = 1;
    var nodeCenterX;
    var nodeMass;
    var nodeCenterY;

  function force() {

    //console.log(sizes);

    var node;
      var i = -1;
      while (++i < iterations){iterate();}
    function iterate(){
          var quadtree = d3.quadtree(nodes, xCenter, yCenter);
          var j = -1;
          while (++j < nodes.length){
            node = nodes[j];
            nodeMass = masses[j];
            nodeCenterX = xCenter(node);
            nodeCenterY = yCenter(node);
            quadtree.visit(collisionDetection);
            }
        }

    function collisionDetection(quad, x0, y0, x1, y1) {
        var updated = false;
        var data = quad.data;
        if(data){
          if (data.index > node.index) {

            let xSize = (node.width + data.width) / 2;
            let ySize = (node.height + data.height) / 2;
            let dataCenterX = xCenter(data);
            let dataCenterY = yCenter(data);
            let dx = nodeCenterX - dataCenterX;
            let dy = nodeCenterY - dataCenterY;
            let absX = Math.abs(dx);
            let absY = Math.abs(dy);
            let xDiff = absX - xSize;
            let yDiff = absY - ySize;

            if(xDiff < 0 && yDiff < 0){
              //collision has occurred
               
              //separation vector
              let sx = xSize - absX;
              let sy = ySize - absY;
              if(sx < sy){
                if(sx > 0){
                  sy = 0;
                }
              }else{
                if(sy > 0){
                  sx = 0;
                }
              }
              if (dx < 0){
                sx = -sx;
              }
              if(dy < 0){
                sy = -sy;
              }

              let distance = Math.sqrt(sx*sx + sy*sy);
              let vCollisionNorm = {x: sx / distance, y: sy / distance};
              let vRelativeVelocity = {x: data.vx - node.vx, y: data.vy - node.vy};
              let speed = vRelativeVelocity.x * vCollisionNorm.x + vRelativeVelocity.y * vCollisionNorm.y;              
              if (speed < 0){
                      //negative speed = rectangles moving away
              }else{
                var collisionImpulse = 2*speed / (masses[data.index] + masses[node.index]);
                if(Math.abs(xDiff) < Math.abs(yDiff)){
                    //x overlap is less
                    data.vx -= (collisionImpulse * masses[node.index] * vCollisionNorm.x);
                    node.vx += (collisionImpulse * masses[data.index] * vCollisionNorm.x);
                  }else{
                    //y overlap is less
                    data.vy -= (collisionImpulse * masses[node.index] * vCollisionNorm.y);
                    node.vy += (collisionImpulse * masses[data.index] * vCollisionNorm.y);
                  }
                  
                updated = true;
              }
            }
          }
        }
      return updated
  }
  }//end force

  function xCenter(d) { return d.x + d.vx + sizes[d.index][0] / 2 }
  function yCenter(d) { return d.y + d.vy + sizes[d.index][1] / 2 }

  force.initialize = function (_) {
      sizes = (nodes = _).map(function(d){return [d.width,d.height]})
      masses = sizes.map(function (d) { return d[0] * d[1] })
  }

force.size = function (_) {
        return (arguments.length
             ? (size = typeof _ === 'function' ? _ : constant(_), force)
             : size)
    }

force.strength = function (_) {
    return (arguments.length ? (strength = +_, force) : strength)
    }

force.iterations = function (_) {
    return (arguments.length ? (iterations = +_, force) : iterations)
    }

return force
}

    </script>
</head>