<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
    <meta http-equiv="x-ua-compatible" content="ie=edge" />
    <title>Wiki Metal Vis</title>

    <!--<link rel="shortcut icon" type="image/jpg" href="/images/favicon.jpg"/> -->
    <!--<script src="./javascripts/forceGraph.js"></script>-->
    <script src="./javascripts/global.js"></script>
    <script src="./javascripts/views.js"></script>
    <!--<script src="https://d3js.org/d3.v4.min.js"></script>-->
    <script src="https://d3js.org/d3.v6.js"></script>
    <script src="https://unpkg.com/d3-force-boundary@0.0.1/dist/d3-force-boundary.min.js"></script> <!--d3 force boundary add on-->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Turf.js/5.1.5/turf.min.js"></script><!--turf for d3 winding order-->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC" crossorigin="anonymous">
    <link href="https://fonts.cdnfonts.com/css/iomanoid" rel="stylesheet"> <!--font-->
    <link href="https://fonts.cdnfonts.com/css/metal-lord" rel="stylesheet"><!--font-->
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Honk"><!--Google font-->
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Permanent+Marker"><!--Google font-->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Wendy+One&display=swap" rel="stylesheet">
    <link rel='stylesheet' href='/stylesheets/style.css' />
    <link rel="stylesheet" href="https://unpkg.com/tippy.js@6/themes/translucent.css"/>
    <link rel="stylesheet" href="https://unpkg.com/tippy.js@6/animations/scale.css"/>
    <script type="text/javascript">

        // get data from controller
        let thrash_bands = JSON.parse(<%-JSON.stringify(ejs_thrash_bands)%>);
        let black_bands = JSON.parse(<%-JSON.stringify(ejs_black_bands)%>);
        let death_bands = JSON.parse(<%-JSON.stringify(ejs_death_bands)%>);
        let world_places = JSON.parse(<%-JSON.stringify(ejs_places)%>);
        let world_states = JSON.parse(<%-JSON.stringify(ejs_states)%>);
        let world_regions = JSON.parse(<%-JSON.stringify(ejs_world_regions)%>);
        let world_boundaries = JSON.parse(<%-JSON.stringify(ejs_map_countries)%>);
        let us_counties = JSON.parse(<%-JSON.stringify(ejs_counties)%>);
        let us_states = JSON.parse(<%-JSON.stringify(ejs_us_states)%>);
        let canada_divisions = JSON.parse(<%-JSON.stringify(ejs_can_divs)%>);
        let german_divisions = JSON.parse(<%-JSON.stringify(ejs_german_divs)%>);
        let german_states = JSON.parse(<%-JSON.stringify(ejs_german_states)%>);
        let metal_continents = JSON.parse(<%-JSON.stringify(ejs_continents)%>);
        let us_state_data = JSON.parse(<%-JSON.stringify(ejs_state_data)%>);

        // global units
        let vhu;
        let vwu;

        // global functions
        let update_chart;

        // global vars and objects
        let animate_timeout;
        let current_projection;
        let simulation;
        let us_region = "Northeast"; 
        let world_region = "South America"; 
        let region = "Australia"; // "United States of America" "United Kingdom"
        let display_region = "World"; // World
        let grouped_region = false;
        let display_continent = "North America"; // not used
        let pop_max = 150000000000;
        let THEME = "dark";
        let current_year = 1979;
        let cap = 90;
        let prev_year;
        let nodes = [];
        let links = [];
        let display_bands_list = [];
        let lookup = {};
        let display_bands = {"thrash":false, "black":false, "death":false};
        let display_genre = "death";
        let changes = false;
        let image_width = 0;
        let base_image_width = 120;
        let min_image_height = 0;
        let max_image_height = 0;
        var timeout = 6000;
        var views;
        let animate = false;
        let map_region;
        
        let projections = {getProjection: function(region, width, height, fixed_states){

                // map view settings from object
                if(region in map_settings){
                    var mapView = map_settings[region];
                    return d3.geoMercator()
                        .center(mapView.centre)
                        .translate([width/2, height/2])
                        .scale(mapView.scale);
                }
                else{ // general fit with padding
                    var padding = 0;
                    if(region in pads){
                        padding = pads[region];
                    }
                    return d3.geoMercator() // ,{"type": "FeatureCollection","features":fixed_states}
                        .fitExtent([[padding, padding], [width-padding,height-padding]], {"type": "FeatureCollection","features":fixed_states});
                }
            }
        }

        // DOM loaded callback
		document.addEventListener('DOMContentLoaded', function() {

            // d3 and geojson
            // https://www.d3indepth.com/geographic/
            // https://github.com/martynafford/natural-earth-geojson/blob/master/10m/cultural/ne_10m_populated_places.json

            // natural earth country names
            // https://unstats.un.org/unsd/methodology/m49/

            // here
            // ticked code clean up plus set height
            // proper label margins from anchors

           // log data
           console.log(thrash_bands);
           console.log(black_bands);
           console.log(death_bands);
           console.log(world_places);
           console.log(world_states);
           console.log(world_regions);
           console.log(world_boundaries);
           console.log(us_counties);
           console.log(us_states);
           console.log(metal_continents);
           console.log(us_state_data);
           console.log(german_divisions);

           // umique cities
           let unique_cities = world_places.features.map(prop => prop.properties.NAME_EN);
           unique_cities.sort();
           console.log(unique_cities);


           // global units
           vhu = parseFloat(window.innerHeight/100);
           vwu = parseFloat(window.innerWidth/100);
           console.log("height and width window units");
           console.log(vhu);
           console.log(vwu);

           // set chart height (bootstrap determines width)
           document.getElementById("plot_div").style.height = "98vh";

           // event listeners
           document.getElementById('yearControl').addEventListener("click", handleYear);

           // set year and area display
           document.getElementById("yearDisplay").innerHTML = current_year;
           if(!(grouped_region)){
                document.getElementById("regionDisplay").innerHTML = region.toUpperCase();
           }
           else{// will need to update for world continents
                if(display_region == "US"){
                    document.getElementById("regionDisplay").innerHTML = "US " + us_region.toUpperCase();
                }
                else{
                    document.getElementById("regionDisplay").innerHTML = world_region.toUpperCase();
                }
           }

           // set genre from display string
           for(let band in display_bands){
            if(band == display_genre){
                display_bands[band] = true;
            }
            else{
                display_bands[band] = false;
            }
           }

           // set genre display and views
           var genre_display = document.getElementById('genreHeader');
           if(display_bands["thrash"]){
            views = thrash_views;
            genre_display.innerHTML = "Thrash Metal"}
           else if(display_bands["death"]){
            views = death_views;
            genre_display.innerHTML = "Death Metal"}
           else{
            views = black_views;
            genre_display.innerHTML = "Black Metal"}

           // init draggable controls
           dragElement(document.getElementById("controls"));

           // set background 
           document.body.style.backgroundColor = "black";
    
           // create bands list and lookup
           display_bands_list = create_bands_list();
           lookup = create_lookup(display_bands_list);

           // set map region
           if(display_region == "World"){
            if(grouped_region){map_region = world_region;}
            else{map_region = region;}
           }
           else{
            if(grouped_region){map_region = us_region;}
            else{map_region = region;}
           }
            
           draw_map();
           update_chart();
           
           // start animation
           animate_timeout = setInterval(myFunction, timeout);

         }, false);

         // varying time interval animation
         var myFunction = function(){
            var skip_years = [2014, 2015, 2017, 2022, 2023];
            clearInterval(animate_timeout);
            if(timeout == 0){
                timeout = 3000;
                return;} // stop from handle year
            if(current_year == 2024){
                clearInterval(animate_timeout);
                return;}
            // update the map
            var year_display = document.getElementById("yearDisplay");
            prev_year = current_year;
            current_year += 1;
            year_display.innerHTML = current_year;
            update_graph_all_genres();
            //if(timeout <= 4500){timeout += 500;}
            
            //if(skip_years.includes(current_year)){timeout = 4000;}
            //else if(current_year <= 1980){timeout = 2000;}
            //else if(current_year <= 1985){timeout = 6000;}
            //else{timeout = 8000;}
            timeout = 10000;
            //if(current_year >= 2014){timeout = 2000;}
            //else if(current_year >= 2020){timeout = 10000;}
            //else{timeout = 10000;}
            //if(current_year == 1985 || current_year == 1987){timeout = 3000;}
            animate_timeout = setInterval(myFunction, timeout);
        }
       
        

         // animate function
         function animate_simple(){
           
            animate_timeout = setInterval(function(){
                var year_display = document.getElementById("yearDisplay");
                prev_year = current_year;
                current_year += 1;
                year_display.innerHTML = current_year;
                update_graph_all_genres();
                if(current_year == 2024){clearInterval(animate_timeout);}
            }, 8000)
         }

         /* EVENT HANDLERS*/
         function handleYear(event){

            // stop animation
            timeout = 0;
            clearInterval(animate_timeout);

            // get direction and handle
            var direction = event.target.id;
            var year_display = document.getElementById("yearDisplay");

            if(direction=='left'){
                if(current_year == 1973){
                    return;
                }
                else{
                    prev_year = current_year;
                    current_year -= 1;
                    year_display.innerHTML = current_year;
                    update_graph_all_genres();
                    return;
                }
            }

            if(direction=='right'){
                if(current_year == 2024){
                    return;
                }
                else{
                    prev_year = current_year;
                    current_year += 1;
                    year_display.innerHTML = current_year;
                    update_graph_all_genres();
                    return;
                }
            }
         }

         //** create and update all (NOTE: remove genres and if)
         function create_graph_all_genres(){
            if(display_bands["thrash"]){
                create_graph(current_projection, lookup, display_bands_list, "thrash");
            }

            if(display_bands["black"]){
                create_graph(current_projection, lookup, display_bands_list, "black");
            }

            if(display_bands["death"]){
                create_graph(current_projection, lookup, display_bands_list, "death");
            }
    
         }

         function update_graph_all_genres(){
            if(display_bands["thrash"]){
                update_graph(current_projection, lookup, display_bands_list, "thrash");
            }

            if(display_bands["black"]){
                update_graph(current_projection, lookup, display_bands_list, "black");
            }

            if(display_bands["death"]){
                update_graph(current_projection, lookup, display_bands_list, "death");
            }
            update_chart();
            changes = false;
         }

         //** check functions

         // check if country in continent
         function in_continent(country){
            for(let i in metal_continents){
                if(metal_continents[i]["name"] == country){
                    if(metal_continents[i]["continent"] == display_continent){
                        return true;
                    }
                    else{
                        return false;
                    }
                }
            }
            return false;
         }

         // check if us state in region
         function in_us_region_fips(state){
            for(let i in us_state_data){
                if(us_state_data[i]["fips_code"] == state){
                    if(us_state_data[i]["region"] == us_region){
                        return true;
                    }
                    else{
                        return false;
                    }
                }
            }
            return false;
         }

         // check if country in world region
         function in_world_region(country){
            return world_regions[world_region].includes(country);
         }

         // check if us state in region
         function in_us_region_name(state){
            for(let i in us_state_data){
                if(us_state_data[i]["name"] == state){
                    if(us_state_data[i]["region"] == us_region){
                        return true;
                    }
                    else{
                        return false;
                    }
                }
            }
            return false;
         }

         // filter band list initially !!
         function create_bands_list(){
            var bands = [];
            if(display_genre == "thrash"){
                var search_bands = thrash_bands;
            }
            else if(display_genre == "death"){
                var search_bands = death_bands;
            }
            else{
                var search_bands = black_bands;
            }

            for(let band of search_bands){
                // US
                if((!(grouped_region) && band['local_rank'] <= cap && display_region == "US" && band['loc']['state'] == region) || 
                        (grouped_region && band['region_rank'] <= cap && display_region == "US" && in_us_region_name (band['loc']['state']))){
                    bands.push(band);

                }

                // World
                if((!(grouped_region) && band['local_rank'] <= cap && display_region == "World" && band['loc']['country'] == region) || 
                        (grouped_region && band['region_rank'] <= cap && display_region == "World" && in_world_region (band['loc']['country']))){
                    bands.push(band);

                }

            }
            return bands;
         }

         // create the lookup data structure
         function create_lookup(bands_list){
            var lookup = {};
            for(let i = 1970; i <= 2025; i++){
                lookup[i] = [];
            }
            for(let band of bands_list){
                for(let year of band['active_years']){
                    lookup[year].push(band['index']);
                }
            }
            return lookup;
         }

         //** update graph
         function update_graph(projection, lookup, bands, genre){
            
            // get indexes
            var prev_band_indexes = lookup[prev_year];
            var curr_band_indexes = lookup[current_year];

            // bands to add/remove
            var add_indexes = curr_band_indexes.filter(i => !prev_band_indexes.includes(i));
            var remove_indexes = prev_band_indexes.filter(i => !curr_band_indexes.includes(i));

            // create new nodes and links
            for(let a of add_indexes){

                // get band
                var band = bands.filter(o => o.index == a)[0];

                // lookup has all of world, filter first?
                if(band == undefined){continue;}

                changes = true;

                // create nodes (2 for eaach band)
                var new_base_node = {"id": "base" + genre + band['index'], "type":genre, "nodeType":"base",
                                        "lat":band['loc']['latitude'], "long":band['loc']['longitude'], "logo": band['logo'],
                                        "fx": projection([band['loc']['longitude'], band['loc']['latitude']])[0],
                                        "fy": projection([band['loc']['longitude'], band['loc']['latitude']])[1],
                                        "x": projection([band['loc']['longitude'], band['loc']['latitude']])[0],
                                        "y": projection([band['loc']['longitude'], band['loc']['latitude']])[1],
                                        "image_size": band["image_size"], "name": band["name"], "genre": band["genre"], "local_region":band["local_region"]};

                var new_band_node = {"id": "band" + genre + band['index'], "type":genre, "nodeType":"band",
                "lat":band['loc']['latitude'], "long":band['loc']['longitude'], "logo": band['logo'],
                "x": projection([band['loc']['longitude'], band['loc']['latitude']])[0],
                "y": projection([band['loc']['longitude'], band['loc']['latitude']])[1],
                "vx": 0.0,
                "vy":0.0,
                "image_size": band["image_size"], "origin": band['origin'], "name": band["name"], "genre": band["genre"], "local_region":band["local_region"]};

                var new_link = {"source":"base" + genre + band['index'], 
                                "target":"band" + genre + band['index'],
                                "type":genre, "image_size": band["image_size"], "name": band["name"]};
                nodes.push(new_base_node);
                nodes.push(new_band_node);
                links.push(new_link);
            
            }

            // remove nodes and links
            for(let r of remove_indexes){

                // get band
                var band = bands.filter(o => o.index == r)[0];

                // lookup has all of world, filter first?
                if(band == undefined){continue;}

                // remove 2 nodes
                nodes = nodes.filter(obj => obj.id != "band" + genre + band['index'] && obj.id != "base" + genre + band['index']);
            
                // remove link
                links = links.filter(obj => obj.source.id != "base" + genre + band['index']);

                changes = true;
            }
         }

         //** create a graph of nodes and edges by current year (initial)
         function create_graph(projection, lookup, bands, genre){

            // current year thrash indexes
            var indexes = lookup[current_year];
            for(let band of bands){

                if(indexes.includes(band['index'])){
                    
                    // create nodes (2 for eaach band) and link
                    var new_base_node = {"id": "base" + genre + band['index'], "type":genre, "nodeType":"base",
                                    "lat":band['loc']['latitude'], "long":band['loc']['longitude'], "logo": band['logo'],
                                    "fx": projection([band['loc']['longitude'], band['loc']['latitude']])[0],
                                    "fy": projection([band['loc']['longitude'], band['loc']['latitude']])[1],
                                    "x": projection([band['loc']['longitude'], band['loc']['latitude']])[0],
                                    "y": projection([band['loc']['longitude'], band['loc']['latitude']])[1],
                                    "image_size": band["image_size"], "name": band["name"], "genre": band["genre"], "local_region":band["local_region"]};

                    var new_band_node = {"id": "band" + genre + band['index'], "type":genre, "nodeType":"band",
                    "lat":band['loc']['latitude'], "long":band['loc']['longitude'], "logo": band['logo'],
                    "x": projection([band['loc']['longitude'], band['loc']['latitude']])[0],
                    "y": projection([band['loc']['longitude'], band['loc']['latitude']])[1],
                    "vx": 0.0,
                    "vy":0.0,
                    "image_size": band["image_size"], "origin": band['origin'], "name": band["name"], "genre": band["genre"], "local_region":band["local_region"]};

                    var new_link = {"source":"base" + genre + band['index'], 
                                "target":"band" + genre + band['index'],
                                "type":genre, "image_size": band["image_size"], "name": band["name"]};

                    nodes.push(new_base_node);
                    nodes.push(new_band_node);
                    links.push(new_link);
                }
                
            }
         }

         //** create a graph of nodes and edges by current year (initial)
         // needs updating for new data
         function create_world_graph(projection, lookup, bands, genre){

            // current year thrash indexes
            for(let band of bands){
                // create nodes (2 for eaach band) and link
                var new_base_node = {"id": "base" + genre + band['index'], "type":genre, "nodeType":"base",
                                "lat":band['loc']['latitude'], "long":band['loc']['longitude'], "logo": band['logo'],
                                "fx": projection([band['loc']['longitude'], band['loc']['latitude']])[0],
                                "fy": projection([band['loc']['longitude'], band['loc']['latitude']])[1],
                                "x": projection([band['loc']['longitude'], band['loc']['latitude']])[0],
                                "y": projection([band['loc']['longitude'], band['loc']['latitude']])[1],
                                "image_size": band["image_size"], "genre": band["genre"], "local_region":band["local_region"]};

                var new_band_node = {"id": "band" + genre + band['index'], "type":genre, "nodeType":"band",
                "lat":band['loc']['latitude'], "long":band['loc']['longitude'], "logo": band['logo'],
                "x": projection([band['loc']['longitude'], band['loc']['latitude']])[0],
                "y": projection([band['loc']['longitude'], band['loc']['latitude']])[1],
                "image_size": band["image_size"], "origin": band['origin'], "genre": band["genre"], "local_region":band["local_region"]};

                var new_link = {"source":"base" + genre + band['index'], 
                            "target":"band" + genre + band['index'],
                            "type":genre, "image_size": band["image_size"]};

                nodes.push(new_base_node);
                nodes.push(new_band_node);
                links.push(new_link);
                
            }
         }

         function draw_map(){
            // get width and height of plot area
            var plot_area = document.getElementById("plot_div");
            var plot_height = plot_area.offsetHeight;
            var plot_width = plot_area.offsetWidth;

            // set the dimensions and margins of the plot 
            // NOTE: dont use for map margind, use padding var in projections instead
            var margin = {top: 0, 
                        right:0, 
                        bottom: 0, 
                        left: 0};

            // chart width and height (leaving names from old code)
            var width = plot_width - margin.left - margin.right;
            var height = plot_height - margin.top - margin.bottom;

            // remove any elements in plot area
            while (plot_area.firstChild) {
                plot_area.removeChild(plot_area.firstChild);
            }

            // zoom
            function zoomed(event) {
                const {transform} = event;
                svg.attr("transform", transform);
                //svg.attr("stroke-width", 1 / transform.k);
            }

            let zoom = d3.zoom()
                .scaleExtent([0.5, 20])
                .on('zoom', zoomed);

            // append the svg object to the plot area
            var svg = d3.select("#plot_div")
            .append("svg")
                .attr("id" , "svgArea")
                .attr("width", width)
                .attr("height", height)
                .attr("viewBox", [0, 0, width, height]) // add zoom here to avoid pan jitter
                .attr("style", "width: 100%; height: auto; height: intrinsic;")
                .style("background-color", function(){
                    if(THEME == "dark"){return "black";}
                    return "white";
                })
                .call(zoom)
            .append("g")
                .attr("transform",
                    "translate(" + margin.left + "," + margin.top + ")");

            // clip path def
            svg.append("defs").append("svg:clipPath")
                .attr("id", "clipID") // don't use same id in other charts
                .append("svg:rect")
                .attr("width", width)
                .attr("height", height)
                .attr("x",0)
                .attr("y",0);
            

            // set map colour and base colour
            // https://simplicable.com/colors/dark-yellow-color ... another color site
            // midnight green .... #004955
            // carribean current .... #105E60
            // darkolive .... #373F38
            // darkslategrey
            // onyx .... #444243
            // crystal teal ... #00637c
            // vintage violet ... #634f62
            // golden brown .... #9B773D
            // bright brown .... #936D58
            // teal .... #016764
            // gunmetal ... #2B3C43
            // blue ... #1B435E
            // lightbrown ... #775E59
            // darklime .... #827717
            // darkgoldenrod
            // lime ... #9E9D24
            // bluegrey ... #607D8B
            let mapColour = ""; // 57,57,57 is background cut-off for alpha
            let baseColour = "";
            let boundaryColour = "";
            if(display_genre == "thrash"){ //  bright brown?  https://icolorpalette.com/download/palette/535890_color_palette.jpg
                mapColour = "darkgoldenrod";  
                baseColour = "lightyellow"; 
                boundaryColour = "black";
                
            }
            else if(display_genre == "black"){ // teal 
                mapColour = "#016764";  
                baseColour = "aliceblue";
                boundaryColour = "black";
            }
            else if(display_genre == "death"){ //  gunmetal
                mapColour = "#936D58"; 
                baseColour = "antiquewhite"; 
                boundaryColour = "black";
                
            }
            else if(display_genre == "power"){//  crystal teal
                mapColour = "#00637c"; 
                baseColour = "beige";
            }
            else if(display_genre == "speed"){ //  
                mapColour = "#775E59"; //  light brown
                baseColour = "cornsilk";
            }
            else if(display_genre == "heavy"){  // vintage violet
                mapColour = "#634f62"; 
                baseColour = "honeydew";
            }
            else if(display_genre == "groove"){ // darkslategrey
                mapColour = "darkslategrey";
                baseColour = "linen";
            }
            else{ // all metal.
                mapColour = "#444243"; // onyx
                baseColour = "lighteblue"; // whitesmoke
            }

            
            //** grads and filters
            //svg = create_light_filter(svg, "lightskyblue");
           // svg = create_light_filter(svg, "whitesmoke");
            //svg = create_light_filter(svg, "antiquewhite"); // reddish for Death
            //svg = create_light_filter(svg, "beige");
            svg = create_light_filter(svg, baseColour);
            //svg = create_light_filter(svg, "cornsilk");
            //svg = create_light_filter(svg, "honeydew");
            svg = create_light_filter_base(svg, "whitesmoke");
            //svg = create_light_filter(svg, "linen");
            svg = create_gradient_filter(svg, mapColour);
            svg = create_gradient_filter_boundary(svg, baseColour);
            svg = create_circle_fill(svg, mapColour, baseColour);
            svg = create_circle_fill_spiral(svg, mapColour, baseColour);
            svg = create_label_fill(svg, baseColour);

            // set display backgrounds
            //document.getElementById("yearDisplay").style.background = 'radial-gradient(' + baseColour + ' 30%, black)';
            document.getElementById("yearDisplay").style.webkitTextStroke  = "3px " + "whitesmoke";
            document.getElementById("yearDisplay").style.textShadow  = "2px 2px 5px " + baseColour;
            //document.getElementById("regionDisplay").style.background = 'radial-gradient(' + baseColour + ' 30%, black)';
            document.getElementById("regionDisplay").style.webkitTextStroke  = "1px " + "whitesmoke";
            //document.getElementById("regionDisplay").style.textShadow  = "2px 2px 5px " + mapColour;
            //document.getElementById("genreHeader").style.background = 'radial-gradient(' + baseColour + ' 30%, black)';
            //document.getElementById("genreHeader").style.color = baseColour;
            document.getElementById("genreHeader").style.webkitTextStroke  = "1px " + "whitesmoke";
            document.getElementById("genreHeader").style.textShadow  = "2px 2px 0px " + mapColour;

            var hrs = document.getElementsByClassName('regionHR');
            for(let hr of hrs){
                hr.style.color = "whitesmoke";
                hr.style.opacity = 0.8;
            }

            // scales
            let radScale = d3.scaleSqrt()
            .domain([pop_max, 10*pop_max])
            .range([1*vhu, 3*vhu]).clamp(true);

            let textScale = d3.scaleLinear()
            .domain([100000, 5000000])
            .range([0.7, 0.7]).clamp(true);

            let imageScale = d3.scaleLinear()// using image range at the moment
            .domain([1, 200])// number of nodes
            .range([40, 15]).clamp(true); 

            /*** Filter Display Map and Background Map  ***/ 
            // us counties and places
            if(display_region == "US"){
                if(!(grouped_region)){
                    var display_states = us_counties.features.filter(prop => prop.properties.STATE == us_state_data[region]["fips_code"]);
                    try{ // look up cities
                        var places_points = world_places.features.filter(prop => prop.properties.ADM1NAME == region);
                        places_points = places_points.filter(prop => views[region]["cities"].includes(prop.properties.NAME));
                    }
                    catch{// use pop if not found
                        var places_points = world_places.features.filter(prop => prop.properties.ADM1NAME == region && prop.properties.POP_MAX > pop_max);
                    }
                    var display_boundary = us_states.features.filter(prop => prop.properties.NAME == region);

                    // background map (states)
                    var world_states_background = world_states.features.filter(prop => prop.properties.admin != "United States of America" && prop.properties.admin != "Canada" && prop.properties.admin != "Antarctica");
                    world_states_background = world_states_background.filter(prop => prop);

                    // background map (boundary)
                    var world_boundaries_background = world_boundaries.features.filter(prop => prop.properties.ADMIN != "United States of America" && prop.properties.ADMIN != "Canada" && prop.properties.ADMIN != "Antarctica");
                    world_boundaries_background = world_boundaries_background.filter(prop => prop);

                    // background us
                    var us_counties_background = us_counties.features.filter(prop => prop.properties.STATE != us_state_data[region]["fips_code"]);
                    var us_boundaries_background = us_states.features.filter(prop => prop.properties.NAME != region);
                }

                // by region Northeast etc
                if(grouped_region){
                    var display_states = us_counties.features.filter(prop => in_us_region_fips(prop.properties.STATE));
                    try{
                        var places_points = world_places.features.filter(prop => in_us_region_name(prop.properties.ADM1NAME));
                        places_points = places_points.filter(prop => views[us_region]["cities"].includes(prop.properties.NAME_EN));
                     
                    }  
                    catch{
                        var places_points = world_places.features.filter(prop => in_us_region_name(prop.properties.ADM1NAME) && prop.properties.POP_MAX > pop_max);
                    }
                    
                    var display_boundary = us_states.features.filter(prop => in_us_region_name(prop.properties.NAME));

                    // background map (states)
                    var world_states_background = world_states.features.filter(prop => prop.properties.admin != "United States of America" && prop.properties.admin != "Canada" && prop.properties.admin != "Antarctica");
                    world_states_background = world_states_background.filter(prop => prop);

                    // background map (boundary)
                    var world_boundaries_background = world_boundaries.features.filter(prop => prop.properties.ADMIN != "United States of America" && prop.properties.ADMIN != "Canada" && prop.properties.ADMIN != "Antarctica");
                    world_boundaries_background = world_boundaries_background.filter(prop => prop);

                    // background us
                    var us_counties_background = us_counties.features.filter(prop => !(in_us_region_fips(prop.properties.STATE)));
                    var us_boundaries_background = us_states.features.filter(prop => !(in_us_region_name(prop.properties.NAME)));

                }
            }   
            else{ // world states and places
                if(!(grouped_region)){
                    var display_states = world_states.features.filter(prop => prop.properties.admin == region);
                    try{ // look up cities
                        var places_points = world_places.features.filter(prop => prop.properties.ADM0NAME == region);
                        places_points = places_points.filter(prop => views[region]["cities"].includes(prop.properties.NAME_EN));
                    }
                    catch{ // use pop max if not found
                        var places_points = world_places.features.filter(prop => prop.properties.ADM0NAME == region && prop.properties.POP_MAX > pop_max);
                    }
                    
                    var display_boundary = world_boundaries.features.filter(prop => prop.properties.ADMIN == region);

                    // background map (states)
                    var world_states_background = world_states.features.filter(prop => prop.properties.admin != "United States of America" && prop.properties.admin != "Canada" && prop.properties.admin != "Antarctica");
                    world_states_background = world_states_background.filter(prop => prop.properties.admin != region);

                    // background map (boundary)
                    var world_boundaries_background = world_boundaries.features.filter(prop => prop.properties.ADMIN != "United States of America" && prop.properties.ADMIN != "Canada" && prop.properties.ADMIN != "Antarctica");
                    world_boundaries_background = world_boundaries_background.filter(prop => prop.properties.ADMIN != region);

                    // background us
                    var us_counties_background = us_counties.features.filter(prop => prop); // consistent with above
                    var us_boundaries_background = us_states.features.filter(prop => prop);
                }

                // by world region 
                if(grouped_region){
                    var display_states = world_states.features.filter(prop => in_world_region(prop.properties.admin));
                    try{
                        var places_points = world_places.features.filter(prop => in_world_region(prop.properties.ADM0NAME));
                        places_points = places_points.filter(prop => views[world_region]["cities"].includes(prop.properties.NAME_EN));
                     
                    }  
                    catch(e){
                        var places_points = world_places.features.filter(prop => in_world_region(prop.properties.ADM0NAME) && prop.properties.POP_MAX > pop_max);
                    }

                    var display_boundary = world_boundaries.features.filter(prop => in_world_region(prop.properties.ADMIN));

                    // background map (states)
                    var world_states_background = world_states.features.filter(prop => prop.properties.admin != "United States of America" && prop.properties.admin != "Canada" && prop.properties.admin != "Antarctica");
                    world_states_background = world_states_background.filter(prop => !(in_world_region(prop.properties.admin)));

                    // background map (boundary)
                    var world_boundaries_background = world_boundaries.features.filter(prop => prop.properties.ADMIN != "United States of America" && prop.properties.ADMIN != "Canada" && prop.properties.ADMIN != "Antarctica");
                    world_boundaries_background = world_boundaries_background.filter(prop => !(in_world_region(prop.properties.ADMIN)));

                    // background us
                    var us_counties_background = us_counties.features.filter(prop => prop); // consistent with above
                    var us_boundaries_background = us_states.features.filter(prop => prop);
                }
            }

            // ** BANCKGROUND

            // filter out null geometries from mapshaper simplification
            world_states_background = world_states_background.filter(feature => feature.geometry !== null);
            var world_states_fixed = world_states_background.map(function(f) {
                    return turf.rewind(f,{reverse:true});
            });

            // filter out null geometries from mapshaper simplification
            world_boundaries_background = world_boundaries_background.filter(feature => feature.geometry !== null);
            // turf unwind features for plot
            var world_boundaries_fixed = world_boundaries_background.map(function(f) {
                    return turf.rewind(f,{reverse:true});
            });
            

            // turf unwind features for plot and filter out null geoms
            us_counties_background = us_counties_background.filter(feature => feature.geometry !== null);
            var us_counties_fixed = us_counties_background.map(function(f) {
                    return turf.rewind(f,{reverse:true});
            });

            // turf unwind features for plot and filter out null geoms
            us_boundaries_background = us_boundaries_background.filter(feature => feature.geometry !== null);
            var us_boundaries_fixed = us_boundaries_background.map(function(f) {
                    return turf.rewind(f,{reverse:true});
            });

            // ** DISPLAY

            // using different german states to match counties
            if(region == "Germany" && display_region == "World" && !(grouped_region)){
                if(!(grouped_region)){
                    display_states = german_divisions.features;
                }
            }

            // turf unwind features for plot and filter out null geoms
            display_states = display_states.filter(feature => feature.geometry !== null);
            var fixed_states = display_states.map(function(f) {
                    return turf.rewind(f,{reverse:true});
            });

            // using different german divisions
            if(region == "Germany" && display_region == "World"){
                if(!(grouped_region)){
                    display_boundary = german_states.features;
                }
            }

            // turf unwind features for plot (boundary)
            display_boundary = display_boundary.filter(feature => feature.geometry !== null);
            var fixed_boundary_states = display_boundary.map(function(f) {
                    return turf.rewind(f,{reverse:true});
            });

            
            // turf unwind features for plot and filter out null geoms
            canada_divisions = canada_divisions.features.filter(feature => feature.geometry !== null);
            var fixed_divisions_canada = canada_divisions.map(function(f) {
                    return turf.rewind(f,{reverse:true});
            });

           
            // get and set current projection
            if(display_region == "World"){
                if(grouped_region){
                    current_projection = projections.getProjection(world_region ,width, height, fixed_states);
                }
                else{
                    current_projection = projections.getProjection(region ,width, height, fixed_states, margin);
                }
            }
            else{ // US
                if(grouped_region){
                    current_projection = projections.getProjection(us_region ,width, height, fixed_states);
                }
                else{
                    current_projection = projections.getProjection(region ,width, height, fixed_states, margin);
                }
            }
            
            // path and graph
            const path = d3.geoPath().projection(current_projection);
            create_graph_all_genres(); //create initial graph (needed for image nodes)

            // ** CUSTOM MARKERS

            // remove jacksonsville north carlonia
            let test_points = [];
            for(let place of places_points){
                if(!(place['properties']['ADM1NAME'] == 'North Carolina' && place['properties']['NAME'] == "Jacksonville")){
                    test_points.push(place);
                }
            }
            places_points = test_points;

            // add custome points (not in json)
            if(display_bands["thrash"]){
                if(region == "Germany"){
                    var new_point = {"geometry":{"coordinates":[7.62082, 47.59331]}, // any pop max its scaled
                            "properties":{"NAME_EN": "Weil am Rhein", "POP_MAX": 100000000}}
                    places_points.push(new_point);
                    var new_point = {"geometry":{"coordinates":[10.22175, 50.04937]}, // any pop max its scaled
                            "properties":{"NAME_EN": "Schweinfurt", "POP_MAX": 100000000}}
                    places_points.push(new_point);
                    var new_point = {"geometry":{"coordinates":[8.016667, 50.883331]}, // any pop max its scaled
                            "properties":{"NAME_EN": "Siegen", "POP_MAX": 100000000}}
                    places_points.push(new_point);
                    var new_point = {"geometry":{"coordinates":[12.10161 , 49.01513]}, // any pop max its scaled
                            "properties":{"NAME_EN": "Regensburg", "POP_MAX": 100000000}}
                    places_points.push(new_point);

                }
            }

            // add custome points (not in json)
            if(display_bands["black"]){
                if(region == "Germany"){
                    var new_point = {"geometry":{"coordinates":[12.641392, 50.59465]}, // any pop max its scaled
                            "properties":{"NAME_EN": "Schneeberg", "POP_MAX": 100000000}}
                    places_points.push(new_point);

                }
                if(us_region == "Northwest"){
                    var new_point = {"geometry":{"coordinates":[-106.9553 , 44.7913]}, // any pop max its scaled
                            "properties":{"NAME_EN": "Sheridan", "POP_MAX": 100000000}}
                    places_points.push(new_point);

                }
            }

            // add radii to points
            for(let place of places_points){
                if(place['properties']['NAME_EN'] in radii){
                    place['radius'] = radii[place['properties']['NAME_EN']];
                }
                else{
                    place['radius'] = 20;
                }
            }

            // add clip path
            svg = svg.append('g')
                .attr("clip-path", "url(#clipID)");

            // * WORLD BACKGROUND
            // background world fill states
            svg
            .append("g")
            .selectAll("world")
            .data(world_states_fixed)
            .join("path")
            .attr("d", path)
            .attr("fill", "url(#circleGradFill)")
            .attr("fill-opacity", 0.1)
            .attr("stroke",mapColour) 
            .attr("class", "world")
            .attr("stroke-width", function(d){
                return  0.5;
            }) 
            .attr("stroke-opacity", function(d){
                    return 0;
            });
            

            // background world stroke countries
            svg
            .append("g")
            .selectAll("world_boundaries")
            .data(world_boundaries_fixed)
            .join("path")
            .attr("d", path)
            .attr("fill", "none")
            .attr("stroke","black") 
            .attr("class", "world")
            .attr("stroke-width", function(d){
                return  1;
            }) 
            .attr("stroke-opacity", function(d){
                    return 0.5;
            });
            

            // backgroundfill us counties
            svg
            .append("g")
            .selectAll("counties")
            .data(us_counties_fixed)
            .join("path")
            .attr("d", path)
            .attr("fill", "url(#circleGradFill)")
            .attr("fill-opacity", 0.1)
            .attr("stroke",mapColour) 
            .attr("class", "world")
            .attr("stroke-width", function(d){
                return  0.5;
            }) 
            .attr("stroke-opacity", function(d){
                    return 0;
            });

            // background us states stroke 
            svg
            .append("g")
            .selectAll("stateboundaries")
            .data(us_boundaries_fixed)
            .join("path")
            .attr("d", path)
            .attr("fill", "none")
            .attr("stroke","black") 
            .attr("class", "world")
            .attr("stroke-width", function(d){
                return  1;
            }) 
            .attr("stroke-opacity", function(d){
                    return 0.5;
            });

            // background canada (only seen from us)
            if(region !== "Canada"){
                svg
                .append("g")
                .selectAll("backdivisions")
                .data(fixed_divisions_canada)
                .join("path")
                .attr("d", path)
                .attr("fill","url(#circleGradFill)")
                .attr("fill-opacity", 0.1)
                .attr("stroke", mapColour)
                .attr("stroke-width", 0.5)
                .attr("stroke-opacity", 0)
                .attr("class", "statearea");
            }

            if(region == "Canada" && display_region == "World" && !(grouped_region)){
                // counties or states
                svg
                .append("g")
                .selectAll("canadapath")
                .data(fixed_divisions_canada)
                .join("path")
                .attr("d", path)
                .attr("fill",function(d){ 
                    return  "url(#circleGradFill)"; //"url(#circleGradFill)";
                }) 
                .attr("fill-opacity",0.7)
                .attr("stroke", function(d){
                    return mapColour;
                })
                .attr("stroke-width", function(d){
                    return  0.5;
                }) 
                .attr("stroke-opacity", function(d){
                    return 0.5;
                })
                .attr("class", "statearea");

            }
            
            // states or divisions
            svg
            .append("g")
            .selectAll("path")
            .data(fixed_states)
            .join("path")
            .attr("d", path)
            .attr("fill",function(d){ // handle canada diff. (germany ok has has own states stroke)
                if(region == "Canada" && display_region == "World" && !(grouped_region)){return 'none';}
                return  "url(#circleGradFill)"; //"url(#circleGradFill)";
            }) 
            .attr("fill-opacity",0.7)
            .attr("stroke", function(d){
                if(region == "Canada" && display_region == "World" && !(grouped_region)){return 'black';}
                return mapColour;
            })
            .attr("stroke-width", function(d){
                if(region == "Canada" && display_region == "World" && !(grouped_region)){return 1;}
                return  0.5;
            }) 
            .attr("stroke-opacity", function(d){
                if(region == "Canada" && display_region == "World" && !(grouped_region)){return 0.5;}
                return 0.5;
            })
            .attr("class", "statearea");

            // boundaries b/w countries
            svg
            .append("g")
            .selectAll("boundary")
            .data(fixed_boundary_states)
            .join("path")
            .attr("d", path)
            .attr("fill", 'none')
            .attr("stroke", boundaryColour) 
            .attr("class", "boundary")
            .attr("stroke-width", function(d){
                return  1;
            }) 
            .attr("stroke-opacity", function(d){
                return 0.5;
            });

            // circle city markers
            svg
            .selectAll("markers")
            .data(places_points)
            .enter()
            .append('circle')
            .attr('cx', d => current_projection(d.geometry.coordinates)[0])
            .attr('cy', d => current_projection(d.geometry.coordinates)[1])
            .attr('r', d => d['radius']) 
            .attr("fill", "black")
            .attr("fill-opacity", 0.5)
            .attr("stroke", "url(#middleCircleFill)") //url(#middleCircleFill)
            .attr("stroke-width", 1)
            .attr("stroke-opacity", 0.5)
            .attr("class", "views");

            // multi-viewers markers
            if(map_region in multi_views){
                
                // add multi view marker
                for(let view of multi_views[map_region]){
                    
                    svg
                    .selectAll("multimarkers")
                    .data([view])
                    .enter()
                    .append('circle')
                    .attr('cx', d => current_projection(d.loc)[0])
                    .attr('cy', d => current_projection(d.loc)[1])
                    .attr('r', d => d['radius']) 
                    .attr("fill", "black")
                    .attr("fill-opacity", 0.5)
                    .attr("stroke", "url(#middleCircleFill)") //url(#middleCircleFill)
                    .attr("stroke-width", 1)
                    .attr("stroke-opacity", 0.5)
                    .attr("class", "views");

                    // add data now to places for text boxes...HERE handle radius for text
                    for(let tag of view.tags){
                        var new_point = {"geometry":{"coordinates":view.loc}, 'radius':view['radius'],// any pop max its scaled
                            "properties":{"NAME_EN": tag, "POP_MAX": 100000000}}
                        places_points.push(new_point);

                    }

                }

            }
        
            
            // add links (here so behind other elements)
            var link = svg.append("g")
            .attr("class", "links")
            .selectAll("edges");

            // add base nodes (circle specular) here so behind 
            var base_node = svg.append("g")
            .attr("class", "nodes")
            .selectAll("bands");

            /*** place names **/
            var place_radius = 20;
            var deltaX = 35;

            // add first for bounding box
            svg
            .selectAll("text")
            .data(places_points)
            .enter()
            .append("text")
            .style('font-size', d => textScale(d.properties.POP_MAX)+"rem")
            .style('font-weight', 700)
            .attr("letter-spacing", "2px")
            .text(d => d.properties.NAME_EN)
            .call(getBB);

            // remove the text elements (watch for other text elements)
            d3.selectAll("text").remove();

            const xMargin = 2;
            const yMargin = 2;
            
            // add background rects
            svg
            .selectAll("textareas")
            .data(places_points)
            .enter()
            .append("rect")
            .attr("class", "maprect")
            .attr("x", function(d){
                if(!(d.properties.NAME_EN in anchors)){ // middle default
                    return current_projection(d.geometry.coordinates)[0] - d.bbox.width/2;
                }
                if(anchors[d.properties.NAME_EN] == "start"){
                    return current_projection(d.geometry.coordinates)[0] + d['radius'];// + xMargin/2;
                };
                if(anchors[d.properties.NAME_EN] == "top"){
                    return current_projection(d.geometry.coordinates)[0] - d.bbox.width/2;
                };
                return current_projection(d.geometry.coordinates)[0]  - d['radius'] - (d.bbox.width) - xMargin/2;
            })
            .attr("y", function(d){
                if(!(d.properties.NAME_EN in anchors)){ // middle default
                    return current_projection(d.geometry.coordinates)[1] + d['radius'] + d.bbox.height/2 + yMargin;
                }
                if(anchors[d.properties.NAME_EN] == "start"){
                    return current_projection(d.geometry.coordinates)[1];
                };
                if(anchors[d.properties.NAME_EN] == "top"){
                    return current_projection(d.geometry.coordinates)[1] - d['radius'] - yMargin;
                };
                if(d.properties.NAME_EN == 'São Paulo'){ // adjust for south america  view 
                    return current_projection(d.geometry.coordinates)[1] - 10;
                }
                return current_projection(d.geometry.coordinates)[1];
            })
            .attr("width", d => d.bbox.width + 2 * xMargin)
            .attr("height", d => d.bbox.height + 2 * yMargin)
            .style("fill", function(){
                if(THEME == "dark"){return "url(#tagGradFill)"}
                return "black";
            })
            .attr("rx", 4)
            .attr("stroke", "grey")
            .attr("stroke-width", 1)
            .style("fill-opacity", 0.8)
            .style("stroke-opacity", 0.8)
            .attr('transform', function(d) {
                return `translate(-${xMargin}, -${d.bbox.height * 0.8 + yMargin})`
                });
            
           // add the text back
           svg
            .selectAll("text")
            .data(places_points)
            .enter()
            .append("text")
            .attr("x", d => current_projection(d.geometry.coordinates)[0])
            .attr("y", d => current_projection(d.geometry.coordinates)[1])
            .attr("dx", function(d){
                if(!(d.properties.NAME_EN in anchors)){ // middle default
                    return 0;
                }
                if(anchors[d.properties.NAME_EN] == "start"){
                    return d['radius'];// + xMargin/2;
                };
                if(anchors[d.properties.NAME_EN] == "top"){
                    return -d.bbox.width/2; // because there is no top anchor
                };
                return -1*d['radius'] - xMargin/2; // end
            })
            .attr("dy", function(d){
                if(!(d.properties.NAME_EN in anchors)){ // middle default
                    return d['radius'] + d.bbox.height/2 + yMargin;
                }
                if(anchors[d.properties.NAME_EN] == "start"){
                    return 0;
                };
                if(anchors[d.properties.NAME_EN] == "top"){
                    return -1*d['radius'] - yMargin;
                };
                if(d.properties.NAME_EN == 'São Paulo'){ // adjust for south america  view 
                    return -10;
                }
                return 0; // end
            })
            //.attr("stroke", function(){
                //if(THEME == "dark"){return "beige"}
                //return "black";
            //})
            .attr("fill", function(){
                if(THEME == "dark"){return "black"}
                return "black";
            })
            .style('font-size', d => textScale(d.properties.POP_MAX)+"rem")
            .style('font-weight', 700)
            .attr("letter-spacing", "2px")
            .attr("text-anchor", function(d){
                if(d.properties.NAME_EN in anchors){
                    return anchors[d.properties.NAME_EN];
                }
                return "middle";
            })
            .text(d => d.properties.NAME_EN);


        /* FORCE SIMULATION */

        // Create a simulation with several forces.
        // https://github.com/ericsoco/d3-force-cluster
        // https://observablehq.com/@d3/force-directed-graph/2?collection=@d3/d3-force
        // collision warming
        // https://stamen.com/forcing-functions-inside-d3-v4-forces-and-layout-transitions-f3e89ee02d12/

        // add band nodes (image) NOTE: need to give image nodes data before update function (for positions i think)
        var no_nodes = nodes.length/2; // account for base nodes
        image_width = base_image_width - Math.ceil(no_nodes/20)*10; // decrease every 14
        min_image_height = image_width/4;
        max_image_height = image_width/2;

        var node = svg.append("g").selectAll("images")
        .data(nodes, d => d.id)
        .enter().append('image')
        .attr("xlink:href", function(d){
            if(d['genre'] == 'made' || d['genre'] == 'modified'){ // made logo
                return "logos_transparent/" + d['genre'] + "/" + d.logo;
            }
            else{
                return "logos_transparent/" + d['genre'] + "/"+ d['local_region'] + "/" + d.logo;
            }

         })
         .attr("width", function(d){

            if(d.nodeType=="base"){
                d['width'] = 0;
                d['height'] = 0;
                return 0;}

            // set from image wwidth and adjust
            var image_height = (image_width/d.image_size[0]) * d.image_size[1];
            var node_width = image_width;
            if(image_height < min_image_height){
                node_width = (min_image_height/d.image_size[1]) * d.image_size[0];
                if(node_width>(1.5*image_width)){ // cap width
                    node_width = 1.5*image_width;
                }

            }
            else if(image_height > max_image_height){
                node_width = (max_image_height/d.image_size[1]) * d.image_size[0];
            
            }

            d['width'] = node_width;
            d['height'] = (node_width/d.image_size[0]) * d.image_size[1];
            return node_width;
            })  
        .attr("class", "nodes")
        .call(d3.drag()
            .on("start", dragstarted)
            .on("drag", dragged)
            .on("end", dragended));

        
        //** Simulation settings  // alphadecay 0.0028  velocitydecay 0.4
        simulation = d3.forceSimulation(nodes).velocityDecay(0.6)//.alphaMin(0.5)//.alphaDecay(0.01)//.velocityDecay(0.4)//.alpha(0.1)..velocityDecay(0.5)//.alphaDecay(0.1)//.velocityDecay(0.8)//.alpha(0.5).alphaDecay(0.1).velocityDecay(0.8)
            .force("link", d3.forceLink(links).id(d => d.id).strength(0.4))
            .force("collide", d3.forceCollide().radius(function(d){
                if(d['nodeType'] == 'band'){
                    if(d.width >= d.height){
                        return d.width/2 + 10;
                    }
                    else{
                        return d.height/2 + 10;
                    }
                }
                else{
                    return 25;
                }
            }).strength(0.2))
            .force("boundary", forceBoundary(0, 0, width, height-100).strength(0.05)) // 0.005
            .on("tick.ticked", ticked);
        
        simulation.nodes(nodes);
        simulation.force("link").links(links); 
        
        // check speed for animation
        function speed(){

            // check all nodes speed
            var speed_min = 0.3;
            var stop = true;
            for(let i=0; i<nodes.length; i++){
                if(Math.abs(nodes[i].vx) > speed_min || Math.abs(nodes[i].vy) > speed_min){
                    stop = false;
                    break;
                }
            }

            // animnate to next year
            var run_pause = true;
            if(stop && nodes.length>0 && current_year < 2024 && run_pause){
                // stop initial animation
                // clearInterval(animate_timeout);

                // delay function
                run_pause = false;
                setTimeout(function(d){
                    run_pause = true;
                }, 6000);

                if(!(animate)){
                    
                    // update the map
                    var year_display = document.getElementById("yearDisplay");
                    prev_year = current_year;
                    current_year += 1;
                    year_display.innerHTML = current_year;
                    update_graph_all_genres();
                }
                
            }
        }
        
        // ticked function
        function ticked() {
            
           
            // source is base
            // HERE: set image height initially amd remove y2 code below
            link
            .attr("x1", d => d.source.x)
            .attr("y1", d => d.source.y)
            .attr("x2", function(d){ // update target point to account for width/height
                return d.target.x + d.target.width/2;
            })
            .attr("y2", function(d){
                return d.target.y + d.target.height/2;
            });
    
            node
            .attr("x", function(d){
                return d.x;
            })
            .attr("y", function(d){
                return d.y;
            });

            
            base_node
            .attr("cx", d => d.x)
            .attr("cy",d => d.y);
            
            
        }

        // global update chart (upate, enter, exit nodes and links)
        update_chart = function(){
            //console.log(nodes);
            //console.log(links);

            // set image width
            var no_nodes = nodes.length/2; // account for base nodes
            image_width = base_image_width - Math.ceil(no_nodes/20)*10; // 60 - 140
            min_image_height = image_width/4;
            max_image_height = image_width/2;
            //console.log(image_width + " image width");

            // let the speed function know its animating
            //animate = true;
            //setTimeout(function(){
                //animate = false;
            //}, 6000);
            
            // Dont use join as messes with exit
            // Instead define seperate enter() amd exit() and use merge as below
            // Always mutate the nodes/links arrays (ie manually add/remove and never overwrite)
            // update (existing), exit (remove old), enter (append new)

            //* base node

            // update existing nodes..HERE transition without data
            if(changes){
                base_node.data(nodes, d => d.id)
                .style("opacity", 0).transition().duration(2000).style("opacity", 0)
                .transition().duration(3000).style("opacity", 1);
            }

            // give back data
            base_node = base_node.data(nodes, d => d.id);

            // exit nodes
            base_node.exit()
            .transition().duration(3000).style("opacity", 0).remove();

            // enter new nodes (diff based on whether in view or not)
            base_node = base_node
                .enter().append("circle")
                .attr("class", "nodes")
                .attr("fill", function(d){
                    if(d.nodeType == "band"){return "none";}
                    return "black";
                })
                .attr("stroke-width", 0)
                .style("stroke-opacity", function(d){
                    var in_view = false;
                    var views = document.getElementsByClassName('views');
                    for(let view of views){
                        // bbox
                        var bb = view.getBBox();

                        // bottom right
                        bb.ax = bb.x + bb.width;
                        bb.ay = bb.y + bb.height;
                    

                        if(bb.x <= d.x && d.x <= bb.ax && bb.y <= d.y && d.y <= bb.ay ) {
                            // Point is in bounding box
                            in_view = true;
                        }
                        
                    }
                    if(in_view){return 0;}
                    return 1;
                })
                .style("fill-opacity", function(d){
                    var in_view = false;
                    var views = document.getElementsByClassName('views');
                    for(let view of views){
                        // bbox
                        var bb = view.getBBox();

                        // bottom right
                        bb.ax = bb.x + bb.width;
                        bb.ay = bb.y + bb.height;
                    

                        if(bb.x <= d.x && d.x <= bb.ax && bb.y <= d.y && d.y <= bb.ay ) {
                            // Point is in bounding box
                            in_view = true;
                        }
                        
                    }
                    if(in_view){return 0;}
                    return 0;
                })
                .attr("filter", function(d){
                    var in_view = false;
                    var views = document.getElementsByClassName('views');
                    for(let view of views){
                        // bbox
                        var bb = view.getBBox();

                        // bottom right
                        bb.ax = bb.x + bb.width;
                        bb.ay = bb.y + bb.height;
                    

                        if(bb.x <= d.x && d.x <= bb.ax && bb.y <= d.y && d.y <= bb.ay ) {
                            // Point is in bounding box
                            in_view = true;
                        }
                        
                    }
                    if(!(in_view)){
                        return "url(#specularwhitesmoke)";
                    }
                    return "url(#specular" + baseColour + ")"
                    
                })
                .attr("r", function(d){
                    if(d.nodeType == "band"){return 0;}
                    
                    var in_view = false;
                    var views = document.getElementsByClassName('views');
                    for(let view of views){
                        // bbox
                        var bb = view.getBBox();

                        // bottom right
                        bb.ax = bb.x + bb.width;
                        bb.ay = bb.y + bb.height;
                    

                        if(bb.x <= d.x && d.x <= bb.ax && bb.y <= d.y && d.y <= bb.ay ) {
                            // Point is in bounding box
                            in_view = true;
                        }
                        
                    }

                    if(in_view){
                        return place_radius;
                    }
                    else{return 8;}

                }).merge(base_node);
            
            
            //** image nodes

            // update existing nodes
            
            if(changes){

                // transition
                node.data(nodes, d => d.id)
                .style("opacity", 0).transition().duration(2000).style("opacity", 0)
                .transition().duration(3000).style("opacity", 1);

                // resize
                node.data(nodes, d => d.id)
                .attr("width", function(d){

                    if(d.nodeType=="base"){
                        d['width'] = 0;
                        d['height'] = 0;
                        return 0;}

                    // set from image wwidth and adjust
                    var image_height = (image_width/d.image_size[0]) * d.image_size[1];
                    var node_width = image_width;
                    if(image_height < min_image_height){
                        node_width = (min_image_height/d.image_size[1]) * d.image_size[0];
                        if(node_width>(1.5*image_width)){ // cap width
                            node_width = 1.5*image_width;
                        }

                    }
                    else if(image_height > max_image_height){
                       node_width = (max_image_height/d.image_size[1]) * d.image_size[0];
                    }

                    d['width'] = node_width;
                    d['height'] = (node_width/d.image_size[0]) * d.image_size[1];
                    return node_width;
                });
                
            }
            

            // then give data
            node = node.data(nodes, d => d.id);
            
            // exit nodes
            node.exit()
            .transition().duration(3000).style("opacity", 0).remove();
            
            // enter new nodes
            node = node
                .enter().append("image")
                .attr("class", "nodes")
                .attr("xlink:href", function(d){
                    if(d['genre'] == 'made' || d['genre'] == 'modified'){ // made logo
                        return "logos_transparent/" + d['genre'] + "/" + d.logo;
                    }
                    else{
                        return "logos_transparent/" + d['genre'] + "/"+ d['local_region'] + "/" + d.logo;
                    }

                })
                .attr("width", function(d){

                    if(d.nodeType=="base"){
                        d['width'] = 0;
                        d['height'] = 0;
                        return 0;}

                    // set from image wwidth and adjust
                    var image_height = (image_width/d.image_size[0]) * d.image_size[1];
                    var node_width = image_width;
                    if(image_height < min_image_height){
                        node_width = (min_image_height/d.image_size[1]) * d.image_size[0];
                        if(node_width>(1.5*image_width)){ // cap width
                            node_width = 1.5*image_width;
                        }

                    }
                    else if(image_height > max_image_height){
                        node_width = (max_image_height/d.image_size[1]) * d.image_size[0]; 
                    }

                    d['width'] = node_width;
                    d['height'] = (node_width/d.image_size[0]) * d.image_size[1];
                    return node_width;
                })
                .call(d3.drag()
                .on("start", dragstarted)
                .on("drag", dragged)
                .on("end", dragended)).merge(node);

            //**  links

            // update existing
            if(changes){
                link.data(links, function(d) { return d.source.id + "-" + d.target.id; })
                .style("opacity", 0).transition().duration(2000).style("opacity", 0)
                .transition().duration(3000).style("opacity", 1);
            }
            
            // then give back data
            link = link.data(links, function(d) { return d.source.id + "-" + d.target.id; });

            // exit links
            link.exit()
            .transition().duration(3000).style("opacity", 0).remove();
            
            // enter new links
            link = link
                .enter()
                .append("line")
                .attr("class", "links")
                .attr("stroke", function(d){
                    return baseColour;
                })
                .attr("stroke-width", 1)
                .attr("stroke-opacity", 0.3)
                .merge(link);
        
                if(changes){
                    simulation
                        .force("link", d3.forceLink(links).id(d => d.id).strength(0.4))
                        .force("collide", d3.forceCollide().radius(function(d){
                        if(d['nodeType'] == 'band'){
                            
                            if(d.width >= d.height){
                                return d.width/2 + 10;
                            }
                            else{
                                return d.height/2 + 10;
                            }
                        }
                        else{
                            return 25;
                        }
                    }).strength(0.2));

                    // regen sim
                    simulation.nodes(nodes);
                    simulation.alpha(0.3).restart().tick();
                    ticked(); // render now!
                }
                
        }

        // get bb of text
        function getBB(selection) {
            selection.each(function(d){d.bbox = this.getBBox();})
        }
            
    }

    
    
        
  // Reheat the simulation when drag starts, and fix the subject position.
  function dragstarted(event) {
    if (!event.active) simulation.alphaTarget(0.3).restart();
    event.subject.fx = event.subject.x;
    event.subject.fy = event.subject.y;
  }

  // Update the subject (dragged node) position during drag.
  function dragged(event) {
    event.subject.fx = event.x;
    event.subject.fy = event.y;
  }

  // Restore the target alpha so the simulation cools after dragging ends.
  // Unfix the subject position now that it’s no longer being dragged.
  function dragended(event) {
    if (!event.active) simulation.alphaTarget(0);
    event.subject.fx = null;
    event.subject.fy = null;
  }

  

    </script>
</head>